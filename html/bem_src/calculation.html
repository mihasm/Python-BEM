<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.1" />
<title>bem_src.calculation API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>bem_src.calculation</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">__author__ = &#34;Miha Smrekar&#34;
__credits__ = [&#34;Miha Smrekar&#34;]
__license__ = &#34;GPL&#34;
__version__ = &#34;0.3.0&#34;
__maintainer__ = &#34;Miha Smrekar&#34;
__email__ = &#34;miha.smrekar9@gmail.com&#34;
__status__ = &#34;Development&#34;

import numbers
from math import sin, cos, atan, acos, pi, exp, sqrt, radians, atan2, degrees, tan
import os

import numpy
import numpy as np
from scipy import interpolate

from utils import Printer, generate_dat, sort_data, normalize_angle
from popravki import *
from xfoil import run_xfoil_analysis, xfoil_runner
from interpolator import interp

numpy.seterr(all=&#34;raise&#34;)
numpy.seterr(invalid=&#34;raise&#34;)


class Calculator:
    &#34;&#34;&#34;
    Class for calculation of induction factors using BEM theory.
    &#34;&#34;&#34;

    def __init__(self, airfoils):
        self.airfoils = airfoils
        for blade_name in self.airfoils:
            self.airfoils[blade_name][&#34;alpha_zero&#34;] = 0.0  # TODO FIX
            generate_dat(
                blade_name, self.airfoils[blade_name][&#34;x&#34;], self.airfoils[blade_name][&#34;y&#34;])

            data = self.airfoils[blade_name][&#34;gathered_curves&#34;]
            data = sort_data(data)

            re = data[:, 0].flatten()
            alpha = data[:, 2].flatten()
            cl = data[:, 3].flatten()
            cd = data[:, 4].flatten()

            def interpolation_function_cl(x, y, re=re, alpha=alpha, cl=cl):
                return interp(x, y, re, alpha, cl)

            def interpolation_function_cd(x, y, re=re, alpha=alpha, cd=cd):
                return interp(x, y, re, alpha, cd)

            self.airfoils[blade_name][&#34;interp_function_cl&#34;] = interpolation_function_cl
            self.airfoils[blade_name][&#34;interp_function_cd&#34;] = interpolation_function_cd

    def printer(self, _locals, p):
        p.print(&#34;----Running induction calculation for following parameters----&#34;)
        for k, v in _locals.items():
            if isinstance(v, dict):
                for k2, v2 in v.items():
                    _p2 = &#34;    &#34; + k2 + &#34;:&#34; + str(v2)
                    p.print(_p2)
            elif isinstance(v, list):
                for l in v:
                    _l = &#34;    &#34; + l
                    p.print(_l)
            else:
                _p = k + &#34;:&#34; + str(v)
                p.print(_p)
        p.print(&#34;-------------------------------------------------------------&#34;)
        return

    def convert_to_array(self, theta, c, r):
        &#34;&#34;&#34;
        Converts integers or floats into numpy arrays.
        :param theta: int or float
        :param c: int or float
        :param r: int or float
        :return: np.array(theta),np.array(c),np.array(r)
        &#34;&#34;&#34;
        if isinstance(theta, numpy.ndarray) and isinstance(c, numpy.ndarray) and isinstance(r, numpy.ndarray):
            return theta, c, r
        else:
            if isinstance(theta, numbers.Real) and isinstance(c, numbers.Real) and isinstance(r, numbers.Real):
                return numpy.array([theta]), numpy.array([c]), numpy.array([r])
            return None

    # noinspection PyUnusedLocal,PyUnusedLocal
    def run_array(self, theta, B, c, r, foils, dr, R, Rhub, rpm, v, pitch, method, propeller_mode, print_out, tip_loss,
                  hub_loss, new_tip_loss, new_hub_loss, cascade_correction, max_iterations, convergence_limit, rho,
                  relaxation_factor, print_all, return_print, return_results, rotational_augmentation_correction,
                  rotational_augmentation_correction_method, mach_number_correction, fix_reynolds, reynolds, *args,
                  **kwargs, ):
        &#34;&#34;&#34;
        Calculates induction factors using standard iteration methods.

        Different methods are available as different fInductionCoefficients functions.

        ANGLES REPRESENTATION SHOWN IN
        https://cmm2017.sciencesconf.org/129068/document
        alpha - angle of attack
        phi - angle of relative wind
        beta - theta

        :param reynolds: Reynolds number (when forced) [float]
        :param fix_reynolds: Force Reynolds number [bool]
        :param mach_number_correction: use only for propeller [bool]
        :param foils: list of airfoils [str]
        :param propeller_mode: if calculating propeller thrust [bool]
        :param rotational_augmentation_correction_method:
        :param rotational_augmentation_correction:
        :param return_results: lst, used for returning results to main class
        :param return_print: lst, used for printing using main class
        :param print_all: prints every iteration
        :param relaxation_factor: relaxation factor
        :param method: method of calculating induction factors
        :param rho: air density [kg/m^3]
        :param convergence_limit: convergence criterion
        :param max_iterations: maximum number of iterations
        :param cascade_correction: uses cascade correction
        :param new_hub_loss: uses new tip loss correction
        :param new_tip_loss: uses new tip loss correction
        :param hub_loss: uses Prandtl tip loss correction
        :param tip_loss: uses Prandtl tip loss correction
        :param print_out: bool; if true, prints iteration data, default: False
        :param v: wind speed [m]
        :param r: sections radiuses [m]
        :param c: sections chord lengths [m]
        :param pitch: blade pitch (twist) [degrees]
        :param theta: twist - theta [deg]
        :param rpm: rotational velocity [rpm]
        :param dr: np array of section heights [m]
        :param R: outer (tip) radius [m]
        :param Rhub: hub radius [m]
        :param B: number of blades
        :return: dicitonary with results
        &#34;&#34;&#34;

        p = Printer(return_print)

        if print_all:
            self.printer(locals(), p=p)

        theta, c, r = self.convert_to_array(theta, c, r)

        # create results array placeholders
        results = {}
        arrays = [&#34;a&#34;, &#34;a&#39;&#34;, &#34;cL&#34;, &#34;alpha&#34;, &#34;phi&#34;, &#34;F&#34;, &#34;dFt&#34;, &#34;M&#34;, &#34;TSR&#34;,
                  &#34;Ct&#34;, &#34;dFn&#34;, &#34;foils&#34;, &#34;dT&#34;, &#34;dQ&#34;, &#34;Re&#34;, &#34;U1&#34;, &#34;U2&#34;, &#34;U3&#34;, &#34;U4&#34;]
        for array in arrays:
            results[array] = numpy.array([])

        # set constants that are section-independent
        omega = rpm * 2 * pi / 60
        TSR = omega * R / v  # tip speed ratio
        J = v / (rpm / 60 * R * 2)
        kin_viscosity = 1.4207E-5  # Kinematic viscosity

        section_number = 0

        for n in range(len(theta)):
            section_number += 1

            _r = r[n]
            _c = c[n]
            _theta = radians(theta[n])
            _airfoil = foils[n]
            _airfoil_dat = _airfoil + &#34;.dat&#34;
            _dr = dr[n]

            if print_out:
                p.print(&#34;    r&#34;, _r, &#34;(&#34; + str(section_number) + &#34;)&#34;)

            # get max thickness
            max_thickness = self.airfoils[_airfoil][&#34;max_thickness&#34;] * _c

            # Coning angle (PROPX: Definitions,Derivations, Data Flow, p.22)
            psi = 0.0

            _locals = locals()
            del _locals[&#34;self&#34;]

            out_results = self.calculate_section(**_locals, printer=p)

            if not print_all and not print_out:
                p.print(&#34;*&#34;, add_newline=False)

            if out_results == None:
                return None

            results[&#34;a&#34;] = numpy.append(results[&#34;a&#34;], out_results[&#34;a&#34;])
            results[&#34;a&#39;&#34;] = numpy.append(results[&#34;a&#39;&#34;], out_results[&#34;aprime&#34;])
            results[&#34;cL&#34;] = numpy.append(results[&#34;cL&#34;], out_results[&#34;Cl&#34;])
            results[&#34;alpha&#34;] = numpy.append(
                results[&#34;alpha&#34;], out_results[&#34;alpha&#34;])
            results[&#34;phi&#34;] = numpy.append(results[&#34;phi&#34;], out_results[&#34;phi&#34;])
            results[&#34;F&#34;] = numpy.append(results[&#34;F&#34;], out_results[&#34;F&#34;])
            results[&#34;dFt&#34;] = numpy.append(results[&#34;dFt&#34;], out_results[&#34;dFt&#34;])
            results[&#34;Ct&#34;] = numpy.append(results[&#34;Ct&#34;], out_results[&#34;Ct&#34;])
            results[&#34;dFn&#34;] = numpy.append(results[&#34;dFn&#34;], out_results[&#34;dFn&#34;])
            results[&#34;foils&#34;] = numpy.append(
                results[&#34;foils&#34;], out_results[&#34;_airfoil&#34;])
            results[&#34;dT&#34;] = numpy.append(results[&#34;dT&#34;], out_results[&#34;dT&#34;])
            results[&#34;dQ&#34;] = numpy.append(results[&#34;dQ&#34;], out_results[&#34;dQ&#34;])
            results[&#34;Re&#34;] = numpy.append(results[&#34;Re&#34;], out_results[&#34;Re&#34;])
            results[&#34;U1&#34;] = numpy.append(results[&#34;U1&#34;], out_results[&#34;U1&#34;])
            results[&#34;U2&#34;] = numpy.append(results[&#34;U2&#34;], out_results[&#34;U2&#34;])
            results[&#34;U3&#34;] = numpy.append(results[&#34;U3&#34;], out_results[&#34;U3&#34;])
            results[&#34;U4&#34;] = numpy.append(results[&#34;U4&#34;], out_results[&#34;U4&#34;])

        if not print_all and not print_out:
            p.print(&#34;&#34;)

        dFt = results[&#34;dFt&#34;]
        Ft = numpy.sum(dFt)
        M = B * dFt * r  # momenti po prerezih
        dQ = results[&#34;dQ&#34;]
        Q = numpy.sum(dQ)  # moment for propeller
        power_p = Q * omega
        Msum = numpy.sum(M)
        power = numpy.sum(M) * omega
        p.print(power_p, power)
        Pmax = 0.5 * rho * v ** 3 * pi * R ** 2
        cp_w = power / Pmax
        cp_p = power_p / (rho * (rpm / 60) ** 3 * (2 * R) ** 5)

        dFn = results[&#34;dFn&#34;]
        Fn = numpy.sum(dFn)
        dT = results[&#34;dT&#34;]
        T = numpy.sum(dT)
        ct_w = T / (0.5 * rho * v ** 2 * pi * R ** 2)
        ct_p = T / (rho * (2 * R) ** 4 * (rpm / 60) ** 2)

        cq_p = Q / (rho * (2*R)**5 * (rpm/60)**2)
        eff_p = J/2/pi*ct_p/cq_p

        results[&#34;R&#34;] = R
        results[&#34;rpm&#34;] = rpm
        results[&#34;v&#34;] = v
        results[&#34;cp_w&#34;] = cp_w
        results[&#34;cp_p&#34;] = cp_p
        results[&#34;ct_w&#34;] = ct_w
        results[&#34;ct_p&#34;] = ct_p
        results[&#34;TSR&#34;] = TSR
        results[&#34;Ft&#34;] = Ft
        results[&#34;r&#34;] = r
        results[&#34;omega&#34;] = omega
        results[&#34;M&#34;] = M
        results[&#34;Msum&#34;] = Msum
        results[&#34;power&#34;] = power
        results[&#34;thrust&#34;] = T
        results[&#34;dFt&#34;] = dFt
        results[&#34;Rhub&#34;] = Rhub
        results[&#34;B&#34;] = B
        results[&#34;dr&#34;] = dr
        results[&#34;c&#34;] = c
        results[&#34;theta&#34;] = theta
        results[&#34;J&#34;] = J
        results[&#34;eff_p&#34;] = eff_p
        return results

    def calculate_section(self, v, omega, _r, _c, _theta, _dr, B, R, _airfoil_dat, _airfoil, max_thickness, Rhub,
                          propeller_mode, pitch=0.0, psi=0.0, fix_reynolds=False, reynolds=1e6, tip_loss=False, new_tip_loss=False,
                          hub_loss=False, new_hub_loss=False, cascade_correction=False, rotational_augmentation_correction=False,
                          rotational_augmentation_correction_method=0, mach_number_correction=False, method=5,
                          kin_viscosity=1.4207E-5, rho=1.225, convergence_limit=0.001, max_iterations=100, relaxation_factor=0.3,
                          printer=None, print_all=False, print_out=False, *args, **kwargs):
        &#34;&#34;&#34;
        Function that calculates each section of the blade.

        Inputs:
        v:float: Wind speed [m/s].
        omega:float: Rotational velocity [s^-1].
        _r:float: Section radius [m].
        _c:float: Section chord length [m].
        _theta:float: Section angle [rad].
        _dr:float: Section height [m].
        B:int: Number of blades.
        R:float: Wind turbine radius [m].
        _airfoil_dat:str: Airfoil file name.
        _airfoil:str: Airfoil name.
        max_thickness:float: Foil thickness in percentage of chord length.
        propeller_mode:bool: Boolean that turns on propeller calculation mode if True.
        pitch:float: Pitch in degrees that adds fixed angle to _theta.
        psi:float: Coning angle.
        fix_reynolds:bool: True if only data at one Reynolds number is to be used.
        reynolds:float: Reynolds number if fix_reynolds is True.
        tip_loss:bool: Prandtl tip loss.
        hub_loss:bool: Prandtl hub loss.
        new_tip_loss:bool: Shen tip loss.
        new_hub_loss:bool: Shen hub loss.
        cascade_correction:bool: Cascade correction.
        rotational_augmentation_correction:bool: Rotational augmentation correction.
        rotational_augmentation_correction_method:int: Rotational augmentation correction method.
        mach_number_correction:bool: Mach number correction (for propellers).
        method:int: Method for calculating axial and tangential induction.
        kin_viscosity:float: Kinematic viscosity.
        rho:float: Air density [kgm^-3].
        convergence_limit:float: Convergence limit.
        max_iterations:int: Maximum iterations.
        relaxation_factor: Relaxation factor.
        &#34;&#34;&#34;

        p = printer

        # local speed ratio
        lambda_r = omega * _r / v

        # solidity
        sigma = _c * B / (2 * pi * _r)

        # initial guess
        a = 1/3
        aprime = 0.01

        # iterations counter
        i = 0

        # tip mach number
        M = omega * _r / 343

        # convert pitch to radians
        _pitch = radians(pitch)

        ############ START ITERATION ############
        while True:
            # update counter
            i = i + 1

            # for pretty-printing only
            prepend = &#34;&#34;

            # wind components
            if propeller_mode:
                Un = v * (1 + a)
                Ut = omega * _r * (1 - aprime)
            else:
                Un = v * (1 - a)
                Ut = omega * _r * (1 + aprime)

            Vrel_norm = sqrt(Un ** 2 + Ut ** 2)

            if fix_reynolds:
                Re = reynolds
            else:
                Re_next = Vrel_norm * _c / kin_viscosity
                if Re_next &gt; 1e7:
                    Re_next = 2e5
                Re = int(Re_next)

            # relative wind
            phi = atan2(Un, Ut)

            F = 1
            # Prandtl tip loss
            if tip_loss:
                F = F * fTipLoss(B, _r, R, phi)

            # New tip loss
            elif new_tip_loss:
                F = F * newTipLoss(B, _r, R, phi, lambda_r)

            # Prandtl hub loss
            if hub_loss:
                F = F * fHubLoss(B, _r, Rhub, phi)

            # New hub loss
            elif new_hub_loss:
                F = F * newHubLoss(B, _r, R, phi, lambda_r)

            # angle of attack
            if propeller_mode:
                alpha = (_theta + _pitch) - phi
            else:
                alpha = phi - (_theta + _pitch)

            alpha = radians(normalize_angle(degrees(alpha)))

            # cascade correction
            if cascade_correction:
                alpha = cascadeEffectsCorrection(alpha=alpha, v=v, omega=omega, r=_r, R=R, c=_c, B=B, a=a,
                                                 aprime=aprime, max_thickness=max_thickness)

            &#34;&#34;&#34;
            # For xFoil cL,cD
            xfoil_return = xfoil_runner(airfoil=_airfoil_dat, reynolds=Re, alpha=alpha, printer=p, print_all=print_all)

            if xfoil_return == False:
                p.print(&#34;        Xfoil failed&#34;)
                return None

            #Cl, Cd = xfoil_return[&#34;CL&#34;], xfoil_return[&#34;CD&#34;] #direct xfoil calculation - no interpolation
            &#34;&#34;&#34;

            Cl, Cd = self.airfoils[_airfoil][&#34;interp_function_cl&#34;](Re, degrees(alpha)), self.airfoils[_airfoil][
                &#34;interp_function_cd&#34;](Re, degrees(alpha))

            if print_all:
                p.print(&#34;        CL:&#34;, Cl, &#34;Cd:&#34;, Cd)

            if rotational_augmentation_correction:
                if print_all:
                    p.print(&#34;--&#34;)
                    p.print(&#34;  Cl:&#34;, Cl, &#34;Cd:&#34;, Cd)
                Cl, Cd = calc_rotational_augmentation_correction(alpha=alpha, Cl=Cl, Cd=Cd, omega=omega, r=_r, R=R,
                                                                 c=_c, theta=_theta, v=v, Vrel=Vrel_norm,
                                                                 method=rotational_augmentation_correction_method,
                                                                 alpha_zero=radians(-5))

                if print_all:
                    p.print(&#34;  Cl_cor:&#34;, Cl, &#34;Cd_cor:&#34;, Cd)
                    p.print(&#34;--&#34;)

            if mach_number_correction:
                Cl = machNumberCorrection(Cl, M)

            # normal and tangential coefficients
            C_norm = Cl * cos(phi) + Cd * sin(phi)
            C_tang = Cl * sin(phi) - Cd * cos(phi)

            # save old values, calculate new values of induction factors
            a_last = a
            aprime_last = aprime

            input_arguments = {&#34;F&#34;: F, &#34;lambda_r&#34;: lambda_r, &#34;phi&#34;: phi, &#34;sigma&#34;: sigma, &#34;C_norm&#34;: C_norm,
                               &#34;C_tang&#34;: C_tang, &#34;Cl&#34;: Cl, &#34;Cd&#34;: Cd, &#34;B&#34;: B, &#34;c&#34;: _c, &#34;r&#34;: _r, &#34;R&#34;: R, &#34;psi&#34;: 0.0,
                               &#34;aprime_last&#34;: aprime, &#34;omega&#34;: omega, &#34;v&#34;: v, &#34;a_last&#34;: a_last,
                               # &#34;alpha_zero&#34;: airfoils[_airfoil][&#34;alpha_zero&#34;],
                               &#34;method&#34;: method, &#34;alpha&#34;: alpha, &#34;alpha_deg&#34;: degrees(alpha)}

            if print_all:
                args_to_print = sorted(
                    [key for key, value in input_arguments.items()])
                p.print(&#34;            i&#34;, i)
                for a in args_to_print:
                    p.print(&#34;            &#34;, a, input_arguments[a])
                p.print(&#34;             --------&#34;)

            # calculate induction coefficients
            coeffs = calculate_coefficients(method, input_arguments)
            if coeffs == None:
                return None
            else:
                a, aprime, Ct = coeffs

            # force calculation
            dFL = Cl * 0.5 * rho * Vrel_norm ** 2 * _c * _dr  # lift force
            dFD = Cd * 0.5 * rho * Vrel_norm ** 2 * _c * _dr  # drag force
            dFt = dFL * sin(phi) - dFD * cos(phi)  # tangential force
            dFn = dFL * cos(phi) + dFD * sin(phi)  # normal force

            # thrust and torque - Wiley, WE 2nd, p.124
            dT_MT = F * 4 * pi * _r * rho * v ** 2 * a * (1 - a) * _dr
            dT_BET = 0.5 * rho * B * _c * Vrel_norm ** 2 * \
                (Cl * cos(phi) + Cd * sin(phi)) * _dr
            dQ_MT = F * 4 * aprime * (1 - a) * rho * \
                v * pi * _r ** 3 * omega * _dr
            dQ_BET = B * 0.5 * rho * Vrel_norm ** 2 * \
                (Cl * sin(phi) - Cd * cos(phi)) * _c * _dr * _r

            # thrust and torque from https://apps.dtic.mil/dtic/tr/fulltext/u2/1013408.pdf
            dT_p = B * rho * (omega * _r / cos(phi) * cos(_theta)
                              ) ** 2 * _c * _dr * (Cl * cos(phi) - Cd * sin(phi))
            dQ_p = B * rho * (omega * _r / cos(phi) * cos(_theta)) ** 2 * _c * _r * _dr * (
                Cl * sin(phi) + Cd * cos(phi))

            # thrust and torque from http://www.icas.org/ICAS_ARCHIVE/ICAS2010/PAPERS/434.PDF
            # dT_p = sigma*pi*rho*v**2*(1+a)**2/(sin(phi)**2)*(Cl*cos(phi)-Cd*sin(phi))*_r*_dr
            # dQ_p = sigma*pi*rho*v**2*(1+a)**2/(sin(phi)*+2)*(Cl*sin(phi)+Cd*cos(phi))*_r**2*_dr

            # thrust-propeller
            dT_MT_p = 4 * pi * _r * rho * v ** 2 * (1 + a) * a * _dr
            dQ_MT_p = 4 * pi * _r ** 3 * rho * \
                v * omega * (1 + a) * aprime * _dr
            dT_BET_p = 0.5 * rho * v ** 2 * _c * B * (1 + a) ** 2 / (sin(phi) ** 2) * (
                Cl * cos(phi) - Cd * sin(phi)) * _dr
            dQ_BET_p = 0.5 * rho * v * _c * B * omega * _r ** 2 * (1 + a) * (1 - aprime) / (sin(phi) * cos(phi)) * (
                Cl * sin(phi) + Cd * cos(phi)) * _dr

            # from http://www.aerodynamics4students.com/propel.m
            dT_BET_p_2 = 0.5*rho*Vrel_norm**2*B*_c * \
                (Cl * cos(phi) - Cd * sin(phi))*_dr
            dQ_BET_p_2 = 0.5*rho*Vrel_norm**2*B*_c * \
                _r*(Cl * sin(phi) + Cd * cos(phi)) * _dr
            dT_MT_p_2 = 4*pi*_r*rho*v**2*(1+a)
            dQ_MT_p_2 = 4*pi*_r**3*rho*v*(1+a)*omega

            if propeller_mode:
                dT = dT_BET_p
                dQ = dQ_BET_p
            else:
                dT = dT_BET
                dQ = dQ_BET

            # wind after
            if propeller_mode:
                U1 = v
                U2 = None
                U3 = U1*(1+a)
                U4 = U1*(1+2*a)
            else:
                U1 = v
                U2 = U1*(1-a)
                U3 = None
                U4 = U1 * (1 - 2 * a)

            # check convergence
            if abs(a - a_last) &lt; convergence_limit and abs(aprime-aprime_last) &lt; convergence_limit:
                break

            # p.print(&#34;dT_MT %.2f dT_BET %.2f&#34; % (dT_MT,dT_BET))

            # check iterations limit
            if i &gt;= max_iterations:
                if print_out:
                    p.print(&#34;-*-*-*-*-*-*-*-*-*-*-*-*-*-\n&#34;, &#34;|max iterations exceeded\n&#34;, &#34;|------&gt;a:&#34;, a, &#34; aprime&#34;,
                            aprime, )
                    prepend = &#34;|&#34;
                return None

            # relaxation
            # aprime=aprime_last+relaxation_factor*(aprime-aprime_last)
            a = a_last + relaxation_factor * (a - a_last)

        ############ END ITERATION ############

        if print_out:
            p.print(prepend, &#34;        iters: &#34;, i)
            p.print(prepend, &#34;        alpha: &#34;, degrees(alpha)), &#34;Cl&#34;, str(Cl)
            p.print(prepend, &#34;        a: &#34;, a, &#34;a&#39;&#34;, str(aprime))
            p.print(prepend, &#34;        LSR: &#34;, lambda_r)
            p.print(prepend, &#34;        Vrel: &#34;, Vrel_norm)
            p.print(prepend, &#34;        Re:&#34;, Re)
            p.print(prepend, &#34;        foil:&#34;, _airfoil_dat)
            p.print(prepend, &#34;        Cl:&#34;, Cl)
            p.print(prepend, &#34;        Cd:&#34;, Cd)
            p.print(prepend, &#34;        U1:&#34;, U1)
            p.print(prepend, &#34;        U2:&#34;, U2)
            p.print(prepend, &#34;        U3:&#34;, U3)
            p.print(prepend, &#34;        U4:&#34;, U4)
            p.print(prepend, &#34;        dT_MT %.2f dT_BET %.2f&#34; %
                    (dT_MT, dT_BET))
            p.print(prepend, &#34;        dQ_MT %.2f dQ_BET %.2f&#34; %
                    (dQ_MT, dQ_BET))
            p.print(prepend, &#34;        dT_MT_p %.5f dT_BET_p %.5f&#34; %
                    (dT_MT_p, dT_BET_p))
            p.print(prepend, &#34;        dQ_MT_p %.5f dQ_BET_p %.5f&#34; %
                    (dQ_MT_p, dQ_BET_p))
            p.print(prepend, &#34;        dT_p %.2f dQ_p %.2f&#34; % (dT_p, dQ_p))
            p.print(prepend, &#34;    ----------------------------&#34;)

        out = {&#34;a&#34;: a, &#34;aprime&#34;: aprime, &#34;Cl&#34;: Cl, &#34;alpha&#34;: alpha, &#34;phi&#34;: phi, &#34;F&#34;: F, &#34;dFt&#34;: dFt, &#34;Ct&#34;: Ct, &#34;dFn&#34;: dFn,
               &#34;_airfoil&#34;: _airfoil_dat, &#34;dT&#34;: dT, &#34;dQ&#34;: dQ, &#34;Re&#34;: Re, &#39;U1&#39;: U1, &#39;U2&#39;: U2, &#39;U3&#39;: U3, &#39;U4&#39;: U4}
        return out</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="bem_src.calculation.Calculator"><code class="flex name class">
<span>class <span class="ident">Calculator</span></span>
<span>(</span><span>airfoils)</span>
</code></dt>
<dd>
<section class="desc"><p>Class for calculation of induction factors using BEM theory.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Calculator:
    &#34;&#34;&#34;
    Class for calculation of induction factors using BEM theory.
    &#34;&#34;&#34;

    def __init__(self, airfoils):
        self.airfoils = airfoils
        for blade_name in self.airfoils:
            self.airfoils[blade_name][&#34;alpha_zero&#34;] = 0.0  # TODO FIX
            generate_dat(
                blade_name, self.airfoils[blade_name][&#34;x&#34;], self.airfoils[blade_name][&#34;y&#34;])

            data = self.airfoils[blade_name][&#34;gathered_curves&#34;]
            data = sort_data(data)

            re = data[:, 0].flatten()
            alpha = data[:, 2].flatten()
            cl = data[:, 3].flatten()
            cd = data[:, 4].flatten()

            def interpolation_function_cl(x, y, re=re, alpha=alpha, cl=cl):
                return interp(x, y, re, alpha, cl)

            def interpolation_function_cd(x, y, re=re, alpha=alpha, cd=cd):
                return interp(x, y, re, alpha, cd)

            self.airfoils[blade_name][&#34;interp_function_cl&#34;] = interpolation_function_cl
            self.airfoils[blade_name][&#34;interp_function_cd&#34;] = interpolation_function_cd

    def printer(self, _locals, p):
        p.print(&#34;----Running induction calculation for following parameters----&#34;)
        for k, v in _locals.items():
            if isinstance(v, dict):
                for k2, v2 in v.items():
                    _p2 = &#34;    &#34; + k2 + &#34;:&#34; + str(v2)
                    p.print(_p2)
            elif isinstance(v, list):
                for l in v:
                    _l = &#34;    &#34; + l
                    p.print(_l)
            else:
                _p = k + &#34;:&#34; + str(v)
                p.print(_p)
        p.print(&#34;-------------------------------------------------------------&#34;)
        return

    def convert_to_array(self, theta, c, r):
        &#34;&#34;&#34;
        Converts integers or floats into numpy arrays.
        :param theta: int or float
        :param c: int or float
        :param r: int or float
        :return: np.array(theta),np.array(c),np.array(r)
        &#34;&#34;&#34;
        if isinstance(theta, numpy.ndarray) and isinstance(c, numpy.ndarray) and isinstance(r, numpy.ndarray):
            return theta, c, r
        else:
            if isinstance(theta, numbers.Real) and isinstance(c, numbers.Real) and isinstance(r, numbers.Real):
                return numpy.array([theta]), numpy.array([c]), numpy.array([r])
            return None

    # noinspection PyUnusedLocal,PyUnusedLocal
    def run_array(self, theta, B, c, r, foils, dr, R, Rhub, rpm, v, pitch, method, propeller_mode, print_out, tip_loss,
                  hub_loss, new_tip_loss, new_hub_loss, cascade_correction, max_iterations, convergence_limit, rho,
                  relaxation_factor, print_all, return_print, return_results, rotational_augmentation_correction,
                  rotational_augmentation_correction_method, mach_number_correction, fix_reynolds, reynolds, *args,
                  **kwargs, ):
        &#34;&#34;&#34;
        Calculates induction factors using standard iteration methods.

        Different methods are available as different fInductionCoefficients functions.

        ANGLES REPRESENTATION SHOWN IN
        https://cmm2017.sciencesconf.org/129068/document
        alpha - angle of attack
        phi - angle of relative wind
        beta - theta

        :param reynolds: Reynolds number (when forced) [float]
        :param fix_reynolds: Force Reynolds number [bool]
        :param mach_number_correction: use only for propeller [bool]
        :param foils: list of airfoils [str]
        :param propeller_mode: if calculating propeller thrust [bool]
        :param rotational_augmentation_correction_method:
        :param rotational_augmentation_correction:
        :param return_results: lst, used for returning results to main class
        :param return_print: lst, used for printing using main class
        :param print_all: prints every iteration
        :param relaxation_factor: relaxation factor
        :param method: method of calculating induction factors
        :param rho: air density [kg/m^3]
        :param convergence_limit: convergence criterion
        :param max_iterations: maximum number of iterations
        :param cascade_correction: uses cascade correction
        :param new_hub_loss: uses new tip loss correction
        :param new_tip_loss: uses new tip loss correction
        :param hub_loss: uses Prandtl tip loss correction
        :param tip_loss: uses Prandtl tip loss correction
        :param print_out: bool; if true, prints iteration data, default: False
        :param v: wind speed [m]
        :param r: sections radiuses [m]
        :param c: sections chord lengths [m]
        :param pitch: blade pitch (twist) [degrees]
        :param theta: twist - theta [deg]
        :param rpm: rotational velocity [rpm]
        :param dr: np array of section heights [m]
        :param R: outer (tip) radius [m]
        :param Rhub: hub radius [m]
        :param B: number of blades
        :return: dicitonary with results
        &#34;&#34;&#34;

        p = Printer(return_print)

        if print_all:
            self.printer(locals(), p=p)

        theta, c, r = self.convert_to_array(theta, c, r)

        # create results array placeholders
        results = {}
        arrays = [&#34;a&#34;, &#34;a&#39;&#34;, &#34;cL&#34;, &#34;alpha&#34;, &#34;phi&#34;, &#34;F&#34;, &#34;dFt&#34;, &#34;M&#34;, &#34;TSR&#34;,
                  &#34;Ct&#34;, &#34;dFn&#34;, &#34;foils&#34;, &#34;dT&#34;, &#34;dQ&#34;, &#34;Re&#34;, &#34;U1&#34;, &#34;U2&#34;, &#34;U3&#34;, &#34;U4&#34;]
        for array in arrays:
            results[array] = numpy.array([])

        # set constants that are section-independent
        omega = rpm * 2 * pi / 60
        TSR = omega * R / v  # tip speed ratio
        J = v / (rpm / 60 * R * 2)
        kin_viscosity = 1.4207E-5  # Kinematic viscosity

        section_number = 0

        for n in range(len(theta)):
            section_number += 1

            _r = r[n]
            _c = c[n]
            _theta = radians(theta[n])
            _airfoil = foils[n]
            _airfoil_dat = _airfoil + &#34;.dat&#34;
            _dr = dr[n]

            if print_out:
                p.print(&#34;    r&#34;, _r, &#34;(&#34; + str(section_number) + &#34;)&#34;)

            # get max thickness
            max_thickness = self.airfoils[_airfoil][&#34;max_thickness&#34;] * _c

            # Coning angle (PROPX: Definitions,Derivations, Data Flow, p.22)
            psi = 0.0

            _locals = locals()
            del _locals[&#34;self&#34;]

            out_results = self.calculate_section(**_locals, printer=p)

            if not print_all and not print_out:
                p.print(&#34;*&#34;, add_newline=False)

            if out_results == None:
                return None

            results[&#34;a&#34;] = numpy.append(results[&#34;a&#34;], out_results[&#34;a&#34;])
            results[&#34;a&#39;&#34;] = numpy.append(results[&#34;a&#39;&#34;], out_results[&#34;aprime&#34;])
            results[&#34;cL&#34;] = numpy.append(results[&#34;cL&#34;], out_results[&#34;Cl&#34;])
            results[&#34;alpha&#34;] = numpy.append(
                results[&#34;alpha&#34;], out_results[&#34;alpha&#34;])
            results[&#34;phi&#34;] = numpy.append(results[&#34;phi&#34;], out_results[&#34;phi&#34;])
            results[&#34;F&#34;] = numpy.append(results[&#34;F&#34;], out_results[&#34;F&#34;])
            results[&#34;dFt&#34;] = numpy.append(results[&#34;dFt&#34;], out_results[&#34;dFt&#34;])
            results[&#34;Ct&#34;] = numpy.append(results[&#34;Ct&#34;], out_results[&#34;Ct&#34;])
            results[&#34;dFn&#34;] = numpy.append(results[&#34;dFn&#34;], out_results[&#34;dFn&#34;])
            results[&#34;foils&#34;] = numpy.append(
                results[&#34;foils&#34;], out_results[&#34;_airfoil&#34;])
            results[&#34;dT&#34;] = numpy.append(results[&#34;dT&#34;], out_results[&#34;dT&#34;])
            results[&#34;dQ&#34;] = numpy.append(results[&#34;dQ&#34;], out_results[&#34;dQ&#34;])
            results[&#34;Re&#34;] = numpy.append(results[&#34;Re&#34;], out_results[&#34;Re&#34;])
            results[&#34;U1&#34;] = numpy.append(results[&#34;U1&#34;], out_results[&#34;U1&#34;])
            results[&#34;U2&#34;] = numpy.append(results[&#34;U2&#34;], out_results[&#34;U2&#34;])
            results[&#34;U3&#34;] = numpy.append(results[&#34;U3&#34;], out_results[&#34;U3&#34;])
            results[&#34;U4&#34;] = numpy.append(results[&#34;U4&#34;], out_results[&#34;U4&#34;])

        if not print_all and not print_out:
            p.print(&#34;&#34;)

        dFt = results[&#34;dFt&#34;]
        Ft = numpy.sum(dFt)
        M = B * dFt * r  # momenti po prerezih
        dQ = results[&#34;dQ&#34;]
        Q = numpy.sum(dQ)  # moment for propeller
        power_p = Q * omega
        Msum = numpy.sum(M)
        power = numpy.sum(M) * omega
        p.print(power_p, power)
        Pmax = 0.5 * rho * v ** 3 * pi * R ** 2
        cp_w = power / Pmax
        cp_p = power_p / (rho * (rpm / 60) ** 3 * (2 * R) ** 5)

        dFn = results[&#34;dFn&#34;]
        Fn = numpy.sum(dFn)
        dT = results[&#34;dT&#34;]
        T = numpy.sum(dT)
        ct_w = T / (0.5 * rho * v ** 2 * pi * R ** 2)
        ct_p = T / (rho * (2 * R) ** 4 * (rpm / 60) ** 2)

        cq_p = Q / (rho * (2*R)**5 * (rpm/60)**2)
        eff_p = J/2/pi*ct_p/cq_p

        results[&#34;R&#34;] = R
        results[&#34;rpm&#34;] = rpm
        results[&#34;v&#34;] = v
        results[&#34;cp_w&#34;] = cp_w
        results[&#34;cp_p&#34;] = cp_p
        results[&#34;ct_w&#34;] = ct_w
        results[&#34;ct_p&#34;] = ct_p
        results[&#34;TSR&#34;] = TSR
        results[&#34;Ft&#34;] = Ft
        results[&#34;r&#34;] = r
        results[&#34;omega&#34;] = omega
        results[&#34;M&#34;] = M
        results[&#34;Msum&#34;] = Msum
        results[&#34;power&#34;] = power
        results[&#34;thrust&#34;] = T
        results[&#34;dFt&#34;] = dFt
        results[&#34;Rhub&#34;] = Rhub
        results[&#34;B&#34;] = B
        results[&#34;dr&#34;] = dr
        results[&#34;c&#34;] = c
        results[&#34;theta&#34;] = theta
        results[&#34;J&#34;] = J
        results[&#34;eff_p&#34;] = eff_p
        return results

    def calculate_section(self, v, omega, _r, _c, _theta, _dr, B, R, _airfoil_dat, _airfoil, max_thickness, Rhub,
                          propeller_mode, pitch=0.0, psi=0.0, fix_reynolds=False, reynolds=1e6, tip_loss=False, new_tip_loss=False,
                          hub_loss=False, new_hub_loss=False, cascade_correction=False, rotational_augmentation_correction=False,
                          rotational_augmentation_correction_method=0, mach_number_correction=False, method=5,
                          kin_viscosity=1.4207E-5, rho=1.225, convergence_limit=0.001, max_iterations=100, relaxation_factor=0.3,
                          printer=None, print_all=False, print_out=False, *args, **kwargs):
        &#34;&#34;&#34;
        Function that calculates each section of the blade.

        Inputs:
        v:float: Wind speed [m/s].
        omega:float: Rotational velocity [s^-1].
        _r:float: Section radius [m].
        _c:float: Section chord length [m].
        _theta:float: Section angle [rad].
        _dr:float: Section height [m].
        B:int: Number of blades.
        R:float: Wind turbine radius [m].
        _airfoil_dat:str: Airfoil file name.
        _airfoil:str: Airfoil name.
        max_thickness:float: Foil thickness in percentage of chord length.
        propeller_mode:bool: Boolean that turns on propeller calculation mode if True.
        pitch:float: Pitch in degrees that adds fixed angle to _theta.
        psi:float: Coning angle.
        fix_reynolds:bool: True if only data at one Reynolds number is to be used.
        reynolds:float: Reynolds number if fix_reynolds is True.
        tip_loss:bool: Prandtl tip loss.
        hub_loss:bool: Prandtl hub loss.
        new_tip_loss:bool: Shen tip loss.
        new_hub_loss:bool: Shen hub loss.
        cascade_correction:bool: Cascade correction.
        rotational_augmentation_correction:bool: Rotational augmentation correction.
        rotational_augmentation_correction_method:int: Rotational augmentation correction method.
        mach_number_correction:bool: Mach number correction (for propellers).
        method:int: Method for calculating axial and tangential induction.
        kin_viscosity:float: Kinematic viscosity.
        rho:float: Air density [kgm^-3].
        convergence_limit:float: Convergence limit.
        max_iterations:int: Maximum iterations.
        relaxation_factor: Relaxation factor.
        &#34;&#34;&#34;

        p = printer

        # local speed ratio
        lambda_r = omega * _r / v

        # solidity
        sigma = _c * B / (2 * pi * _r)

        # initial guess
        a = 1/3
        aprime = 0.01

        # iterations counter
        i = 0

        # tip mach number
        M = omega * _r / 343

        # convert pitch to radians
        _pitch = radians(pitch)

        ############ START ITERATION ############
        while True:
            # update counter
            i = i + 1

            # for pretty-printing only
            prepend = &#34;&#34;

            # wind components
            if propeller_mode:
                Un = v * (1 + a)
                Ut = omega * _r * (1 - aprime)
            else:
                Un = v * (1 - a)
                Ut = omega * _r * (1 + aprime)

            Vrel_norm = sqrt(Un ** 2 + Ut ** 2)

            if fix_reynolds:
                Re = reynolds
            else:
                Re_next = Vrel_norm * _c / kin_viscosity
                if Re_next &gt; 1e7:
                    Re_next = 2e5
                Re = int(Re_next)

            # relative wind
            phi = atan2(Un, Ut)

            F = 1
            # Prandtl tip loss
            if tip_loss:
                F = F * fTipLoss(B, _r, R, phi)

            # New tip loss
            elif new_tip_loss:
                F = F * newTipLoss(B, _r, R, phi, lambda_r)

            # Prandtl hub loss
            if hub_loss:
                F = F * fHubLoss(B, _r, Rhub, phi)

            # New hub loss
            elif new_hub_loss:
                F = F * newHubLoss(B, _r, R, phi, lambda_r)

            # angle of attack
            if propeller_mode:
                alpha = (_theta + _pitch) - phi
            else:
                alpha = phi - (_theta + _pitch)

            alpha = radians(normalize_angle(degrees(alpha)))

            # cascade correction
            if cascade_correction:
                alpha = cascadeEffectsCorrection(alpha=alpha, v=v, omega=omega, r=_r, R=R, c=_c, B=B, a=a,
                                                 aprime=aprime, max_thickness=max_thickness)

            &#34;&#34;&#34;
            # For xFoil cL,cD
            xfoil_return = xfoil_runner(airfoil=_airfoil_dat, reynolds=Re, alpha=alpha, printer=p, print_all=print_all)

            if xfoil_return == False:
                p.print(&#34;        Xfoil failed&#34;)
                return None

            #Cl, Cd = xfoil_return[&#34;CL&#34;], xfoil_return[&#34;CD&#34;] #direct xfoil calculation - no interpolation
            &#34;&#34;&#34;

            Cl, Cd = self.airfoils[_airfoil][&#34;interp_function_cl&#34;](Re, degrees(alpha)), self.airfoils[_airfoil][
                &#34;interp_function_cd&#34;](Re, degrees(alpha))

            if print_all:
                p.print(&#34;        CL:&#34;, Cl, &#34;Cd:&#34;, Cd)

            if rotational_augmentation_correction:
                if print_all:
                    p.print(&#34;--&#34;)
                    p.print(&#34;  Cl:&#34;, Cl, &#34;Cd:&#34;, Cd)
                Cl, Cd = calc_rotational_augmentation_correction(alpha=alpha, Cl=Cl, Cd=Cd, omega=omega, r=_r, R=R,
                                                                 c=_c, theta=_theta, v=v, Vrel=Vrel_norm,
                                                                 method=rotational_augmentation_correction_method,
                                                                 alpha_zero=radians(-5))

                if print_all:
                    p.print(&#34;  Cl_cor:&#34;, Cl, &#34;Cd_cor:&#34;, Cd)
                    p.print(&#34;--&#34;)

            if mach_number_correction:
                Cl = machNumberCorrection(Cl, M)

            # normal and tangential coefficients
            C_norm = Cl * cos(phi) + Cd * sin(phi)
            C_tang = Cl * sin(phi) - Cd * cos(phi)

            # save old values, calculate new values of induction factors
            a_last = a
            aprime_last = aprime

            input_arguments = {&#34;F&#34;: F, &#34;lambda_r&#34;: lambda_r, &#34;phi&#34;: phi, &#34;sigma&#34;: sigma, &#34;C_norm&#34;: C_norm,
                               &#34;C_tang&#34;: C_tang, &#34;Cl&#34;: Cl, &#34;Cd&#34;: Cd, &#34;B&#34;: B, &#34;c&#34;: _c, &#34;r&#34;: _r, &#34;R&#34;: R, &#34;psi&#34;: 0.0,
                               &#34;aprime_last&#34;: aprime, &#34;omega&#34;: omega, &#34;v&#34;: v, &#34;a_last&#34;: a_last,
                               # &#34;alpha_zero&#34;: airfoils[_airfoil][&#34;alpha_zero&#34;],
                               &#34;method&#34;: method, &#34;alpha&#34;: alpha, &#34;alpha_deg&#34;: degrees(alpha)}

            if print_all:
                args_to_print = sorted(
                    [key for key, value in input_arguments.items()])
                p.print(&#34;            i&#34;, i)
                for a in args_to_print:
                    p.print(&#34;            &#34;, a, input_arguments[a])
                p.print(&#34;             --------&#34;)

            # calculate induction coefficients
            coeffs = calculate_coefficients(method, input_arguments)
            if coeffs == None:
                return None
            else:
                a, aprime, Ct = coeffs

            # force calculation
            dFL = Cl * 0.5 * rho * Vrel_norm ** 2 * _c * _dr  # lift force
            dFD = Cd * 0.5 * rho * Vrel_norm ** 2 * _c * _dr  # drag force
            dFt = dFL * sin(phi) - dFD * cos(phi)  # tangential force
            dFn = dFL * cos(phi) + dFD * sin(phi)  # normal force

            # thrust and torque - Wiley, WE 2nd, p.124
            dT_MT = F * 4 * pi * _r * rho * v ** 2 * a * (1 - a) * _dr
            dT_BET = 0.5 * rho * B * _c * Vrel_norm ** 2 * \
                (Cl * cos(phi) + Cd * sin(phi)) * _dr
            dQ_MT = F * 4 * aprime * (1 - a) * rho * \
                v * pi * _r ** 3 * omega * _dr
            dQ_BET = B * 0.5 * rho * Vrel_norm ** 2 * \
                (Cl * sin(phi) - Cd * cos(phi)) * _c * _dr * _r

            # thrust and torque from https://apps.dtic.mil/dtic/tr/fulltext/u2/1013408.pdf
            dT_p = B * rho * (omega * _r / cos(phi) * cos(_theta)
                              ) ** 2 * _c * _dr * (Cl * cos(phi) - Cd * sin(phi))
            dQ_p = B * rho * (omega * _r / cos(phi) * cos(_theta)) ** 2 * _c * _r * _dr * (
                Cl * sin(phi) + Cd * cos(phi))

            # thrust and torque from http://www.icas.org/ICAS_ARCHIVE/ICAS2010/PAPERS/434.PDF
            # dT_p = sigma*pi*rho*v**2*(1+a)**2/(sin(phi)**2)*(Cl*cos(phi)-Cd*sin(phi))*_r*_dr
            # dQ_p = sigma*pi*rho*v**2*(1+a)**2/(sin(phi)*+2)*(Cl*sin(phi)+Cd*cos(phi))*_r**2*_dr

            # thrust-propeller
            dT_MT_p = 4 * pi * _r * rho * v ** 2 * (1 + a) * a * _dr
            dQ_MT_p = 4 * pi * _r ** 3 * rho * \
                v * omega * (1 + a) * aprime * _dr
            dT_BET_p = 0.5 * rho * v ** 2 * _c * B * (1 + a) ** 2 / (sin(phi) ** 2) * (
                Cl * cos(phi) - Cd * sin(phi)) * _dr
            dQ_BET_p = 0.5 * rho * v * _c * B * omega * _r ** 2 * (1 + a) * (1 - aprime) / (sin(phi) * cos(phi)) * (
                Cl * sin(phi) + Cd * cos(phi)) * _dr

            # from http://www.aerodynamics4students.com/propel.m
            dT_BET_p_2 = 0.5*rho*Vrel_norm**2*B*_c * \
                (Cl * cos(phi) - Cd * sin(phi))*_dr
            dQ_BET_p_2 = 0.5*rho*Vrel_norm**2*B*_c * \
                _r*(Cl * sin(phi) + Cd * cos(phi)) * _dr
            dT_MT_p_2 = 4*pi*_r*rho*v**2*(1+a)
            dQ_MT_p_2 = 4*pi*_r**3*rho*v*(1+a)*omega

            if propeller_mode:
                dT = dT_BET_p
                dQ = dQ_BET_p
            else:
                dT = dT_BET
                dQ = dQ_BET

            # wind after
            if propeller_mode:
                U1 = v
                U2 = None
                U3 = U1*(1+a)
                U4 = U1*(1+2*a)
            else:
                U1 = v
                U2 = U1*(1-a)
                U3 = None
                U4 = U1 * (1 - 2 * a)

            # check convergence
            if abs(a - a_last) &lt; convergence_limit and abs(aprime-aprime_last) &lt; convergence_limit:
                break

            # p.print(&#34;dT_MT %.2f dT_BET %.2f&#34; % (dT_MT,dT_BET))

            # check iterations limit
            if i &gt;= max_iterations:
                if print_out:
                    p.print(&#34;-*-*-*-*-*-*-*-*-*-*-*-*-*-\n&#34;, &#34;|max iterations exceeded\n&#34;, &#34;|------&gt;a:&#34;, a, &#34; aprime&#34;,
                            aprime, )
                    prepend = &#34;|&#34;
                return None

            # relaxation
            # aprime=aprime_last+relaxation_factor*(aprime-aprime_last)
            a = a_last + relaxation_factor * (a - a_last)

        ############ END ITERATION ############

        if print_out:
            p.print(prepend, &#34;        iters: &#34;, i)
            p.print(prepend, &#34;        alpha: &#34;, degrees(alpha)), &#34;Cl&#34;, str(Cl)
            p.print(prepend, &#34;        a: &#34;, a, &#34;a&#39;&#34;, str(aprime))
            p.print(prepend, &#34;        LSR: &#34;, lambda_r)
            p.print(prepend, &#34;        Vrel: &#34;, Vrel_norm)
            p.print(prepend, &#34;        Re:&#34;, Re)
            p.print(prepend, &#34;        foil:&#34;, _airfoil_dat)
            p.print(prepend, &#34;        Cl:&#34;, Cl)
            p.print(prepend, &#34;        Cd:&#34;, Cd)
            p.print(prepend, &#34;        U1:&#34;, U1)
            p.print(prepend, &#34;        U2:&#34;, U2)
            p.print(prepend, &#34;        U3:&#34;, U3)
            p.print(prepend, &#34;        U4:&#34;, U4)
            p.print(prepend, &#34;        dT_MT %.2f dT_BET %.2f&#34; %
                    (dT_MT, dT_BET))
            p.print(prepend, &#34;        dQ_MT %.2f dQ_BET %.2f&#34; %
                    (dQ_MT, dQ_BET))
            p.print(prepend, &#34;        dT_MT_p %.5f dT_BET_p %.5f&#34; %
                    (dT_MT_p, dT_BET_p))
            p.print(prepend, &#34;        dQ_MT_p %.5f dQ_BET_p %.5f&#34; %
                    (dQ_MT_p, dQ_BET_p))
            p.print(prepend, &#34;        dT_p %.2f dQ_p %.2f&#34; % (dT_p, dQ_p))
            p.print(prepend, &#34;    ----------------------------&#34;)

        out = {&#34;a&#34;: a, &#34;aprime&#34;: aprime, &#34;Cl&#34;: Cl, &#34;alpha&#34;: alpha, &#34;phi&#34;: phi, &#34;F&#34;: F, &#34;dFt&#34;: dFt, &#34;Ct&#34;: Ct, &#34;dFn&#34;: dFn,
               &#34;_airfoil&#34;: _airfoil_dat, &#34;dT&#34;: dT, &#34;dQ&#34;: dQ, &#34;Re&#34;: Re, &#39;U1&#39;: U1, &#39;U2&#39;: U2, &#39;U3&#39;: U3, &#39;U4&#39;: U4}
        return out</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="bem_src.calculation.Calculator.calculate_section"><code class="name flex">
<span>def <span class="ident">calculate_section</span></span>(<span>self, v, omega, _r, _c, _theta, _dr, B, R, _airfoil_dat, _airfoil, max_thickness, Rhub, propeller_mode, pitch=0.0, psi=0.0, fix_reynolds=False, reynolds=1000000.0, tip_loss=False, new_tip_loss=False, hub_loss=False, new_hub_loss=False, cascade_correction=False, rotational_augmentation_correction=False, rotational_augmentation_correction_method=0, mach_number_correction=False, method=5, kin_viscosity=1.4207e-05, rho=1.225, convergence_limit=0.001, max_iterations=100, relaxation_factor=0.3, printer=None, print_all=False, print_out=False, *args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Function that calculates each section of the blade.</p>
<p>Inputs:
v:float: Wind speed [m/s].
omega:float: Rotational velocity [s^-1].
_r:float: Section radius [m].
_c:float: Section chord length [m].
_theta:float: Section angle [rad].
_dr:float: Section height [m].
B:int: Number of blades.
R:float: Wind turbine radius [m].
_airfoil_dat:str: Airfoil file name.
_airfoil:str: Airfoil name.
max_thickness:float: Foil thickness in percentage of chord length.
propeller_mode:bool: Boolean that turns on propeller calculation mode if True.
pitch:float: Pitch in degrees that adds fixed angle to _theta.
psi:float: Coning angle.
fix_reynolds:bool: True if only data at one Reynolds number is to be used.
reynolds:float: Reynolds number if fix_reynolds is True.
tip_loss:bool: Prandtl tip loss.
hub_loss:bool: Prandtl hub loss.
new_tip_loss:bool: Shen tip loss.
new_hub_loss:bool: Shen hub loss.
cascade_correction:bool: Cascade correction.
rotational_augmentation_correction:bool: Rotational augmentation correction.
rotational_augmentation_correction_method:int: Rotational augmentation correction method.
mach_number_correction:bool: Mach number correction (for propellers).
method:int: Method for calculating axial and tangential induction.
kin_viscosity:float: Kinematic viscosity.
rho:float: Air density [kgm^-3].
convergence_limit:float: Convergence limit.
max_iterations:int: Maximum iterations.
relaxation_factor: Relaxation factor.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_section(self, v, omega, _r, _c, _theta, _dr, B, R, _airfoil_dat, _airfoil, max_thickness, Rhub,
                      propeller_mode, pitch=0.0, psi=0.0, fix_reynolds=False, reynolds=1e6, tip_loss=False, new_tip_loss=False,
                      hub_loss=False, new_hub_loss=False, cascade_correction=False, rotational_augmentation_correction=False,
                      rotational_augmentation_correction_method=0, mach_number_correction=False, method=5,
                      kin_viscosity=1.4207E-5, rho=1.225, convergence_limit=0.001, max_iterations=100, relaxation_factor=0.3,
                      printer=None, print_all=False, print_out=False, *args, **kwargs):
    &#34;&#34;&#34;
    Function that calculates each section of the blade.

    Inputs:
    v:float: Wind speed [m/s].
    omega:float: Rotational velocity [s^-1].
    _r:float: Section radius [m].
    _c:float: Section chord length [m].
    _theta:float: Section angle [rad].
    _dr:float: Section height [m].
    B:int: Number of blades.
    R:float: Wind turbine radius [m].
    _airfoil_dat:str: Airfoil file name.
    _airfoil:str: Airfoil name.
    max_thickness:float: Foil thickness in percentage of chord length.
    propeller_mode:bool: Boolean that turns on propeller calculation mode if True.
    pitch:float: Pitch in degrees that adds fixed angle to _theta.
    psi:float: Coning angle.
    fix_reynolds:bool: True if only data at one Reynolds number is to be used.
    reynolds:float: Reynolds number if fix_reynolds is True.
    tip_loss:bool: Prandtl tip loss.
    hub_loss:bool: Prandtl hub loss.
    new_tip_loss:bool: Shen tip loss.
    new_hub_loss:bool: Shen hub loss.
    cascade_correction:bool: Cascade correction.
    rotational_augmentation_correction:bool: Rotational augmentation correction.
    rotational_augmentation_correction_method:int: Rotational augmentation correction method.
    mach_number_correction:bool: Mach number correction (for propellers).
    method:int: Method for calculating axial and tangential induction.
    kin_viscosity:float: Kinematic viscosity.
    rho:float: Air density [kgm^-3].
    convergence_limit:float: Convergence limit.
    max_iterations:int: Maximum iterations.
    relaxation_factor: Relaxation factor.
    &#34;&#34;&#34;

    p = printer

    # local speed ratio
    lambda_r = omega * _r / v

    # solidity
    sigma = _c * B / (2 * pi * _r)

    # initial guess
    a = 1/3
    aprime = 0.01

    # iterations counter
    i = 0

    # tip mach number
    M = omega * _r / 343

    # convert pitch to radians
    _pitch = radians(pitch)

    ############ START ITERATION ############
    while True:
        # update counter
        i = i + 1

        # for pretty-printing only
        prepend = &#34;&#34;

        # wind components
        if propeller_mode:
            Un = v * (1 + a)
            Ut = omega * _r * (1 - aprime)
        else:
            Un = v * (1 - a)
            Ut = omega * _r * (1 + aprime)

        Vrel_norm = sqrt(Un ** 2 + Ut ** 2)

        if fix_reynolds:
            Re = reynolds
        else:
            Re_next = Vrel_norm * _c / kin_viscosity
            if Re_next &gt; 1e7:
                Re_next = 2e5
            Re = int(Re_next)

        # relative wind
        phi = atan2(Un, Ut)

        F = 1
        # Prandtl tip loss
        if tip_loss:
            F = F * fTipLoss(B, _r, R, phi)

        # New tip loss
        elif new_tip_loss:
            F = F * newTipLoss(B, _r, R, phi, lambda_r)

        # Prandtl hub loss
        if hub_loss:
            F = F * fHubLoss(B, _r, Rhub, phi)

        # New hub loss
        elif new_hub_loss:
            F = F * newHubLoss(B, _r, R, phi, lambda_r)

        # angle of attack
        if propeller_mode:
            alpha = (_theta + _pitch) - phi
        else:
            alpha = phi - (_theta + _pitch)

        alpha = radians(normalize_angle(degrees(alpha)))

        # cascade correction
        if cascade_correction:
            alpha = cascadeEffectsCorrection(alpha=alpha, v=v, omega=omega, r=_r, R=R, c=_c, B=B, a=a,
                                             aprime=aprime, max_thickness=max_thickness)

        &#34;&#34;&#34;
        # For xFoil cL,cD
        xfoil_return = xfoil_runner(airfoil=_airfoil_dat, reynolds=Re, alpha=alpha, printer=p, print_all=print_all)

        if xfoil_return == False:
            p.print(&#34;        Xfoil failed&#34;)
            return None

        #Cl, Cd = xfoil_return[&#34;CL&#34;], xfoil_return[&#34;CD&#34;] #direct xfoil calculation - no interpolation
        &#34;&#34;&#34;

        Cl, Cd = self.airfoils[_airfoil][&#34;interp_function_cl&#34;](Re, degrees(alpha)), self.airfoils[_airfoil][
            &#34;interp_function_cd&#34;](Re, degrees(alpha))

        if print_all:
            p.print(&#34;        CL:&#34;, Cl, &#34;Cd:&#34;, Cd)

        if rotational_augmentation_correction:
            if print_all:
                p.print(&#34;--&#34;)
                p.print(&#34;  Cl:&#34;, Cl, &#34;Cd:&#34;, Cd)
            Cl, Cd = calc_rotational_augmentation_correction(alpha=alpha, Cl=Cl, Cd=Cd, omega=omega, r=_r, R=R,
                                                             c=_c, theta=_theta, v=v, Vrel=Vrel_norm,
                                                             method=rotational_augmentation_correction_method,
                                                             alpha_zero=radians(-5))

            if print_all:
                p.print(&#34;  Cl_cor:&#34;, Cl, &#34;Cd_cor:&#34;, Cd)
                p.print(&#34;--&#34;)

        if mach_number_correction:
            Cl = machNumberCorrection(Cl, M)

        # normal and tangential coefficients
        C_norm = Cl * cos(phi) + Cd * sin(phi)
        C_tang = Cl * sin(phi) - Cd * cos(phi)

        # save old values, calculate new values of induction factors
        a_last = a
        aprime_last = aprime

        input_arguments = {&#34;F&#34;: F, &#34;lambda_r&#34;: lambda_r, &#34;phi&#34;: phi, &#34;sigma&#34;: sigma, &#34;C_norm&#34;: C_norm,
                           &#34;C_tang&#34;: C_tang, &#34;Cl&#34;: Cl, &#34;Cd&#34;: Cd, &#34;B&#34;: B, &#34;c&#34;: _c, &#34;r&#34;: _r, &#34;R&#34;: R, &#34;psi&#34;: 0.0,
                           &#34;aprime_last&#34;: aprime, &#34;omega&#34;: omega, &#34;v&#34;: v, &#34;a_last&#34;: a_last,
                           # &#34;alpha_zero&#34;: airfoils[_airfoil][&#34;alpha_zero&#34;],
                           &#34;method&#34;: method, &#34;alpha&#34;: alpha, &#34;alpha_deg&#34;: degrees(alpha)}

        if print_all:
            args_to_print = sorted(
                [key for key, value in input_arguments.items()])
            p.print(&#34;            i&#34;, i)
            for a in args_to_print:
                p.print(&#34;            &#34;, a, input_arguments[a])
            p.print(&#34;             --------&#34;)

        # calculate induction coefficients
        coeffs = calculate_coefficients(method, input_arguments)
        if coeffs == None:
            return None
        else:
            a, aprime, Ct = coeffs

        # force calculation
        dFL = Cl * 0.5 * rho * Vrel_norm ** 2 * _c * _dr  # lift force
        dFD = Cd * 0.5 * rho * Vrel_norm ** 2 * _c * _dr  # drag force
        dFt = dFL * sin(phi) - dFD * cos(phi)  # tangential force
        dFn = dFL * cos(phi) + dFD * sin(phi)  # normal force

        # thrust and torque - Wiley, WE 2nd, p.124
        dT_MT = F * 4 * pi * _r * rho * v ** 2 * a * (1 - a) * _dr
        dT_BET = 0.5 * rho * B * _c * Vrel_norm ** 2 * \
            (Cl * cos(phi) + Cd * sin(phi)) * _dr
        dQ_MT = F * 4 * aprime * (1 - a) * rho * \
            v * pi * _r ** 3 * omega * _dr
        dQ_BET = B * 0.5 * rho * Vrel_norm ** 2 * \
            (Cl * sin(phi) - Cd * cos(phi)) * _c * _dr * _r

        # thrust and torque from https://apps.dtic.mil/dtic/tr/fulltext/u2/1013408.pdf
        dT_p = B * rho * (omega * _r / cos(phi) * cos(_theta)
                          ) ** 2 * _c * _dr * (Cl * cos(phi) - Cd * sin(phi))
        dQ_p = B * rho * (omega * _r / cos(phi) * cos(_theta)) ** 2 * _c * _r * _dr * (
            Cl * sin(phi) + Cd * cos(phi))

        # thrust and torque from http://www.icas.org/ICAS_ARCHIVE/ICAS2010/PAPERS/434.PDF
        # dT_p = sigma*pi*rho*v**2*(1+a)**2/(sin(phi)**2)*(Cl*cos(phi)-Cd*sin(phi))*_r*_dr
        # dQ_p = sigma*pi*rho*v**2*(1+a)**2/(sin(phi)*+2)*(Cl*sin(phi)+Cd*cos(phi))*_r**2*_dr

        # thrust-propeller
        dT_MT_p = 4 * pi * _r * rho * v ** 2 * (1 + a) * a * _dr
        dQ_MT_p = 4 * pi * _r ** 3 * rho * \
            v * omega * (1 + a) * aprime * _dr
        dT_BET_p = 0.5 * rho * v ** 2 * _c * B * (1 + a) ** 2 / (sin(phi) ** 2) * (
            Cl * cos(phi) - Cd * sin(phi)) * _dr
        dQ_BET_p = 0.5 * rho * v * _c * B * omega * _r ** 2 * (1 + a) * (1 - aprime) / (sin(phi) * cos(phi)) * (
            Cl * sin(phi) + Cd * cos(phi)) * _dr

        # from http://www.aerodynamics4students.com/propel.m
        dT_BET_p_2 = 0.5*rho*Vrel_norm**2*B*_c * \
            (Cl * cos(phi) - Cd * sin(phi))*_dr
        dQ_BET_p_2 = 0.5*rho*Vrel_norm**2*B*_c * \
            _r*(Cl * sin(phi) + Cd * cos(phi)) * _dr
        dT_MT_p_2 = 4*pi*_r*rho*v**2*(1+a)
        dQ_MT_p_2 = 4*pi*_r**3*rho*v*(1+a)*omega

        if propeller_mode:
            dT = dT_BET_p
            dQ = dQ_BET_p
        else:
            dT = dT_BET
            dQ = dQ_BET

        # wind after
        if propeller_mode:
            U1 = v
            U2 = None
            U3 = U1*(1+a)
            U4 = U1*(1+2*a)
        else:
            U1 = v
            U2 = U1*(1-a)
            U3 = None
            U4 = U1 * (1 - 2 * a)

        # check convergence
        if abs(a - a_last) &lt; convergence_limit and abs(aprime-aprime_last) &lt; convergence_limit:
            break

        # p.print(&#34;dT_MT %.2f dT_BET %.2f&#34; % (dT_MT,dT_BET))

        # check iterations limit
        if i &gt;= max_iterations:
            if print_out:
                p.print(&#34;-*-*-*-*-*-*-*-*-*-*-*-*-*-\n&#34;, &#34;|max iterations exceeded\n&#34;, &#34;|------&gt;a:&#34;, a, &#34; aprime&#34;,
                        aprime, )
                prepend = &#34;|&#34;
            return None

        # relaxation
        # aprime=aprime_last+relaxation_factor*(aprime-aprime_last)
        a = a_last + relaxation_factor * (a - a_last)

    ############ END ITERATION ############

    if print_out:
        p.print(prepend, &#34;        iters: &#34;, i)
        p.print(prepend, &#34;        alpha: &#34;, degrees(alpha)), &#34;Cl&#34;, str(Cl)
        p.print(prepend, &#34;        a: &#34;, a, &#34;a&#39;&#34;, str(aprime))
        p.print(prepend, &#34;        LSR: &#34;, lambda_r)
        p.print(prepend, &#34;        Vrel: &#34;, Vrel_norm)
        p.print(prepend, &#34;        Re:&#34;, Re)
        p.print(prepend, &#34;        foil:&#34;, _airfoil_dat)
        p.print(prepend, &#34;        Cl:&#34;, Cl)
        p.print(prepend, &#34;        Cd:&#34;, Cd)
        p.print(prepend, &#34;        U1:&#34;, U1)
        p.print(prepend, &#34;        U2:&#34;, U2)
        p.print(prepend, &#34;        U3:&#34;, U3)
        p.print(prepend, &#34;        U4:&#34;, U4)
        p.print(prepend, &#34;        dT_MT %.2f dT_BET %.2f&#34; %
                (dT_MT, dT_BET))
        p.print(prepend, &#34;        dQ_MT %.2f dQ_BET %.2f&#34; %
                (dQ_MT, dQ_BET))
        p.print(prepend, &#34;        dT_MT_p %.5f dT_BET_p %.5f&#34; %
                (dT_MT_p, dT_BET_p))
        p.print(prepend, &#34;        dQ_MT_p %.5f dQ_BET_p %.5f&#34; %
                (dQ_MT_p, dQ_BET_p))
        p.print(prepend, &#34;        dT_p %.2f dQ_p %.2f&#34; % (dT_p, dQ_p))
        p.print(prepend, &#34;    ----------------------------&#34;)

    out = {&#34;a&#34;: a, &#34;aprime&#34;: aprime, &#34;Cl&#34;: Cl, &#34;alpha&#34;: alpha, &#34;phi&#34;: phi, &#34;F&#34;: F, &#34;dFt&#34;: dFt, &#34;Ct&#34;: Ct, &#34;dFn&#34;: dFn,
           &#34;_airfoil&#34;: _airfoil_dat, &#34;dT&#34;: dT, &#34;dQ&#34;: dQ, &#34;Re&#34;: Re, &#39;U1&#39;: U1, &#39;U2&#39;: U2, &#39;U3&#39;: U3, &#39;U4&#39;: U4}
    return out</code></pre>
</details>
</dd>
<dt id="bem_src.calculation.Calculator.convert_to_array"><code class="name flex">
<span>def <span class="ident">convert_to_array</span></span>(<span>self, theta, c, r)</span>
</code></dt>
<dd>
<section class="desc"><p>Converts integers or floats into numpy arrays.
:param theta: int or float
:param c: int or float
:param r: int or float
:return: np.array(theta),np.array(c),np.array(r)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert_to_array(self, theta, c, r):
    &#34;&#34;&#34;
    Converts integers or floats into numpy arrays.
    :param theta: int or float
    :param c: int or float
    :param r: int or float
    :return: np.array(theta),np.array(c),np.array(r)
    &#34;&#34;&#34;
    if isinstance(theta, numpy.ndarray) and isinstance(c, numpy.ndarray) and isinstance(r, numpy.ndarray):
        return theta, c, r
    else:
        if isinstance(theta, numbers.Real) and isinstance(c, numbers.Real) and isinstance(r, numbers.Real):
            return numpy.array([theta]), numpy.array([c]), numpy.array([r])
        return None</code></pre>
</details>
</dd>
<dt id="bem_src.calculation.Calculator.printer"><code class="name flex">
<span>def <span class="ident">printer</span></span>(<span>self, _locals, p)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def printer(self, _locals, p):
    p.print(&#34;----Running induction calculation for following parameters----&#34;)
    for k, v in _locals.items():
        if isinstance(v, dict):
            for k2, v2 in v.items():
                _p2 = &#34;    &#34; + k2 + &#34;:&#34; + str(v2)
                p.print(_p2)
        elif isinstance(v, list):
            for l in v:
                _l = &#34;    &#34; + l
                p.print(_l)
        else:
            _p = k + &#34;:&#34; + str(v)
            p.print(_p)
    p.print(&#34;-------------------------------------------------------------&#34;)
    return</code></pre>
</details>
</dd>
<dt id="bem_src.calculation.Calculator.run_array"><code class="name flex">
<span>def <span class="ident">run_array</span></span>(<span>self, theta, B, c, r, foils, dr, R, Rhub, rpm, v, pitch, method, propeller_mode, print_out, tip_loss, hub_loss, new_tip_loss, new_hub_loss, cascade_correction, max_iterations, convergence_limit, rho, relaxation_factor, print_all, return_print, return_results, rotational_augmentation_correction, rotational_augmentation_correction_method, mach_number_correction, fix_reynolds, reynolds, *args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Calculates induction factors using standard iteration methods.</p>
<p>Different methods are available as different fInductionCoefficients functions.</p>
<p>ANGLES REPRESENTATION SHOWN IN
<a href="https://cmm2017.sciencesconf.org/129068/document">https://cmm2017.sciencesconf.org/129068/document</a>
alpha - angle of attack
phi - angle of relative wind
beta - theta</p>
<p>:param reynolds: Reynolds number (when forced) [float]
:param fix_reynolds: Force Reynolds number [bool]
:param mach_number_correction: use only for propeller [bool]
:param foils: list of airfoils [str]
:param propeller_mode: if calculating propeller thrust [bool]
:param rotational_augmentation_correction_method:
:param rotational_augmentation_correction:
:param return_results: lst, used for returning results to main class
:param return_print: lst, used for printing using main class
:param print_all: prints every iteration
:param relaxation_factor: relaxation factor
:param method: method of calculating induction factors
:param rho: air density [kg/m^3]
:param convergence_limit: convergence criterion
:param max_iterations: maximum number of iterations
:param cascade_correction: uses cascade correction
:param new_hub_loss: uses new tip loss correction
:param new_tip_loss: uses new tip loss correction
:param hub_loss: uses Prandtl tip loss correction
:param tip_loss: uses Prandtl tip loss correction
:param print_out: bool; if true, prints iteration data, default: False
:param v: wind speed [m]
:param r: sections radiuses [m]
:param c: sections chord lengths [m]
:param pitch: blade pitch (twist) [degrees]
:param theta: twist - theta [deg]
:param rpm: rotational velocity [rpm]
:param dr: np array of section heights [m]
:param R: outer (tip) radius [m]
:param Rhub: hub radius [m]
:param B: number of blades
:return: dicitonary with results</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_array(self, theta, B, c, r, foils, dr, R, Rhub, rpm, v, pitch, method, propeller_mode, print_out, tip_loss,
              hub_loss, new_tip_loss, new_hub_loss, cascade_correction, max_iterations, convergence_limit, rho,
              relaxation_factor, print_all, return_print, return_results, rotational_augmentation_correction,
              rotational_augmentation_correction_method, mach_number_correction, fix_reynolds, reynolds, *args,
              **kwargs, ):
    &#34;&#34;&#34;
    Calculates induction factors using standard iteration methods.

    Different methods are available as different fInductionCoefficients functions.

    ANGLES REPRESENTATION SHOWN IN
    https://cmm2017.sciencesconf.org/129068/document
    alpha - angle of attack
    phi - angle of relative wind
    beta - theta

    :param reynolds: Reynolds number (when forced) [float]
    :param fix_reynolds: Force Reynolds number [bool]
    :param mach_number_correction: use only for propeller [bool]
    :param foils: list of airfoils [str]
    :param propeller_mode: if calculating propeller thrust [bool]
    :param rotational_augmentation_correction_method:
    :param rotational_augmentation_correction:
    :param return_results: lst, used for returning results to main class
    :param return_print: lst, used for printing using main class
    :param print_all: prints every iteration
    :param relaxation_factor: relaxation factor
    :param method: method of calculating induction factors
    :param rho: air density [kg/m^3]
    :param convergence_limit: convergence criterion
    :param max_iterations: maximum number of iterations
    :param cascade_correction: uses cascade correction
    :param new_hub_loss: uses new tip loss correction
    :param new_tip_loss: uses new tip loss correction
    :param hub_loss: uses Prandtl tip loss correction
    :param tip_loss: uses Prandtl tip loss correction
    :param print_out: bool; if true, prints iteration data, default: False
    :param v: wind speed [m]
    :param r: sections radiuses [m]
    :param c: sections chord lengths [m]
    :param pitch: blade pitch (twist) [degrees]
    :param theta: twist - theta [deg]
    :param rpm: rotational velocity [rpm]
    :param dr: np array of section heights [m]
    :param R: outer (tip) radius [m]
    :param Rhub: hub radius [m]
    :param B: number of blades
    :return: dicitonary with results
    &#34;&#34;&#34;

    p = Printer(return_print)

    if print_all:
        self.printer(locals(), p=p)

    theta, c, r = self.convert_to_array(theta, c, r)

    # create results array placeholders
    results = {}
    arrays = [&#34;a&#34;, &#34;a&#39;&#34;, &#34;cL&#34;, &#34;alpha&#34;, &#34;phi&#34;, &#34;F&#34;, &#34;dFt&#34;, &#34;M&#34;, &#34;TSR&#34;,
              &#34;Ct&#34;, &#34;dFn&#34;, &#34;foils&#34;, &#34;dT&#34;, &#34;dQ&#34;, &#34;Re&#34;, &#34;U1&#34;, &#34;U2&#34;, &#34;U3&#34;, &#34;U4&#34;]
    for array in arrays:
        results[array] = numpy.array([])

    # set constants that are section-independent
    omega = rpm * 2 * pi / 60
    TSR = omega * R / v  # tip speed ratio
    J = v / (rpm / 60 * R * 2)
    kin_viscosity = 1.4207E-5  # Kinematic viscosity

    section_number = 0

    for n in range(len(theta)):
        section_number += 1

        _r = r[n]
        _c = c[n]
        _theta = radians(theta[n])
        _airfoil = foils[n]
        _airfoil_dat = _airfoil + &#34;.dat&#34;
        _dr = dr[n]

        if print_out:
            p.print(&#34;    r&#34;, _r, &#34;(&#34; + str(section_number) + &#34;)&#34;)

        # get max thickness
        max_thickness = self.airfoils[_airfoil][&#34;max_thickness&#34;] * _c

        # Coning angle (PROPX: Definitions,Derivations, Data Flow, p.22)
        psi = 0.0

        _locals = locals()
        del _locals[&#34;self&#34;]

        out_results = self.calculate_section(**_locals, printer=p)

        if not print_all and not print_out:
            p.print(&#34;*&#34;, add_newline=False)

        if out_results == None:
            return None

        results[&#34;a&#34;] = numpy.append(results[&#34;a&#34;], out_results[&#34;a&#34;])
        results[&#34;a&#39;&#34;] = numpy.append(results[&#34;a&#39;&#34;], out_results[&#34;aprime&#34;])
        results[&#34;cL&#34;] = numpy.append(results[&#34;cL&#34;], out_results[&#34;Cl&#34;])
        results[&#34;alpha&#34;] = numpy.append(
            results[&#34;alpha&#34;], out_results[&#34;alpha&#34;])
        results[&#34;phi&#34;] = numpy.append(results[&#34;phi&#34;], out_results[&#34;phi&#34;])
        results[&#34;F&#34;] = numpy.append(results[&#34;F&#34;], out_results[&#34;F&#34;])
        results[&#34;dFt&#34;] = numpy.append(results[&#34;dFt&#34;], out_results[&#34;dFt&#34;])
        results[&#34;Ct&#34;] = numpy.append(results[&#34;Ct&#34;], out_results[&#34;Ct&#34;])
        results[&#34;dFn&#34;] = numpy.append(results[&#34;dFn&#34;], out_results[&#34;dFn&#34;])
        results[&#34;foils&#34;] = numpy.append(
            results[&#34;foils&#34;], out_results[&#34;_airfoil&#34;])
        results[&#34;dT&#34;] = numpy.append(results[&#34;dT&#34;], out_results[&#34;dT&#34;])
        results[&#34;dQ&#34;] = numpy.append(results[&#34;dQ&#34;], out_results[&#34;dQ&#34;])
        results[&#34;Re&#34;] = numpy.append(results[&#34;Re&#34;], out_results[&#34;Re&#34;])
        results[&#34;U1&#34;] = numpy.append(results[&#34;U1&#34;], out_results[&#34;U1&#34;])
        results[&#34;U2&#34;] = numpy.append(results[&#34;U2&#34;], out_results[&#34;U2&#34;])
        results[&#34;U3&#34;] = numpy.append(results[&#34;U3&#34;], out_results[&#34;U3&#34;])
        results[&#34;U4&#34;] = numpy.append(results[&#34;U4&#34;], out_results[&#34;U4&#34;])

    if not print_all and not print_out:
        p.print(&#34;&#34;)

    dFt = results[&#34;dFt&#34;]
    Ft = numpy.sum(dFt)
    M = B * dFt * r  # momenti po prerezih
    dQ = results[&#34;dQ&#34;]
    Q = numpy.sum(dQ)  # moment for propeller
    power_p = Q * omega
    Msum = numpy.sum(M)
    power = numpy.sum(M) * omega
    p.print(power_p, power)
    Pmax = 0.5 * rho * v ** 3 * pi * R ** 2
    cp_w = power / Pmax
    cp_p = power_p / (rho * (rpm / 60) ** 3 * (2 * R) ** 5)

    dFn = results[&#34;dFn&#34;]
    Fn = numpy.sum(dFn)
    dT = results[&#34;dT&#34;]
    T = numpy.sum(dT)
    ct_w = T / (0.5 * rho * v ** 2 * pi * R ** 2)
    ct_p = T / (rho * (2 * R) ** 4 * (rpm / 60) ** 2)

    cq_p = Q / (rho * (2*R)**5 * (rpm/60)**2)
    eff_p = J/2/pi*ct_p/cq_p

    results[&#34;R&#34;] = R
    results[&#34;rpm&#34;] = rpm
    results[&#34;v&#34;] = v
    results[&#34;cp_w&#34;] = cp_w
    results[&#34;cp_p&#34;] = cp_p
    results[&#34;ct_w&#34;] = ct_w
    results[&#34;ct_p&#34;] = ct_p
    results[&#34;TSR&#34;] = TSR
    results[&#34;Ft&#34;] = Ft
    results[&#34;r&#34;] = r
    results[&#34;omega&#34;] = omega
    results[&#34;M&#34;] = M
    results[&#34;Msum&#34;] = Msum
    results[&#34;power&#34;] = power
    results[&#34;thrust&#34;] = T
    results[&#34;dFt&#34;] = dFt
    results[&#34;Rhub&#34;] = Rhub
    results[&#34;B&#34;] = B
    results[&#34;dr&#34;] = dr
    results[&#34;c&#34;] = c
    results[&#34;theta&#34;] = theta
    results[&#34;J&#34;] = J
    results[&#34;eff_p&#34;] = eff_p
    return results</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="bem_src" href="index.html">bem_src</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="bem_src.calculation.Calculator" href="#bem_src.calculation.Calculator">Calculator</a></code></h4>
<ul class="">
<li><code><a title="bem_src.calculation.Calculator.calculate_section" href="#bem_src.calculation.Calculator.calculate_section">calculate_section</a></code></li>
<li><code><a title="bem_src.calculation.Calculator.convert_to_array" href="#bem_src.calculation.Calculator.convert_to_array">convert_to_array</a></code></li>
<li><code><a title="bem_src.calculation.Calculator.printer" href="#bem_src.calculation.Calculator.printer">printer</a></code></li>
<li><code><a title="bem_src.calculation.Calculator.run_array" href="#bem_src.calculation.Calculator.run_array">run_array</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>