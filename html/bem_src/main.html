<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.1" />
<title>bem_src.main API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>bem_src.main</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">__author__ = &#34;Miha Smrekar&#34;
__credits__ = [&#34;Miha Smrekar&#34;]
__license__ = &#34;GPL&#34;
__version__ = &#34;0.3.0&#34;
__maintainer__ = &#34;Miha Smrekar&#34;
__email__ = &#34;miha.smrekar9@gmail.com&#34;
__status__ = &#34;Development&#34;


from utils import get_centroid_coordinates
from sw_macro_builder import create_macro_text
from visualize import create_3d_blade
from xfoil import generate_polars_data
from montgomerie import Montgomerie
from polars import scrape_data
from interpolator import interp_at
from utils import interpolate_geom, to_float, fltr
from optimization import optimize_angles_genetic, maximize_for_both, optimal_pitch
from utils import interpolate_geom, to_float, fltr, QDarkPalette, create_folder
from turbine_data import SET_INIT
from table import Table
from results import ResultsWindow
from calculation_runner import calculate_power_3d
from matplotlib import cm
import mpl_toolkits.mplot3d as mp3d
from matplotlib.widgets import Slider, Button, RadioButtons
import matplotlib.pyplot as plt
from matplotlib.backends.backend_qt4agg import NavigationToolbar2QT as NavigationToolbar
from matplotlib.backends.backend_qt4agg import FigureCanvasQTAgg as FigureCanvas
from scipy.interpolate import interp1d
from scipy import interpolate
import numpy as np
from numpy import array
from PyQt5.QtGui import QPalette, QColor
from PyQt5.QtWidgets import (QComboBox, QMainWindow, QPushButton, QTextEdit, QWidget, QFormLayout,
                             QLabel, QLineEdit, QGridLayout, QCheckBox, QStyleFactory, QMessageBox, QAction, QFileDialog, QSlider)
from PyQt5 import QtCore, QtGui
from PyQt5.QtCore import QThread, QTextStream, pyqtSignal, QProcess, QRect, Qt
from PyQt5 import QtWidgets
from multiprocessing import Process, Manager
import multiprocessing
import json
from pprint import pprint
import time
import sys
import ctypes
import os

import numpy
numpy.set_printoptions(threshold=sys.maxsize)


TITLE_STR = &#34;BEM analiza v%s&#34; % __version__

METHODS_STRINGS = {&#34;0&#34;: &#34;Original&#34;, &#34;1&#34;: &#34;b) Spera&#34;, &#34;2&#34;: &#34;Wiley: Strip theory, incl. wake rot.&#34;,
                   &#34;3&#34;: &#34;Grant Ingram (without Ct corr.)&#34;, &#34;4&#34;: &#34;f) Glauert empirical&#34;, &#34;5&#34;: &#34;Propx&#34;,
                   &#34;6&#34;: &#34;e) Aerodyn (Buhl)&#34;, &#34;7&#34;: &#34;QBlade (Buhl)&#34;, &#34;8&#34;: &#34;d) Shen&#34;, &#34;9&#34;: &#34;a) Glauert&#34;,
                   &#34;10&#34;: &#34;Wilson and Walker&#34;, &#34;11&#34;: &#34;Classical brake state model&#34;, &#34;12&#34;: &#34;Advanced brake state model&#34;,
                   &#34;13&#34;: &#34;c) Modified ABS model&#34;, &#34;14&#34;: &#34;Propeller BEM&#34;}


class MainWindow(QMainWindow):
    emitter_add = pyqtSignal(str)
    emitter_done = pyqtSignal()

    def __init__(self, width, height):
        super().__init__()

        self.statusBar()
        mainMenu = self.menuBar()
        fileMenu = mainMenu.addMenu(&#39;&amp;File&#39;)
        saveFile = QAction(&#34;&amp;Save File&#34;, self)
        saveFile.setShortcut(&#34;Ctrl+S&#34;)
        saveFile.setStatusTip(&#39;Save File&#39;)
        saveFile.triggered.connect(self.file_save)
        loadFile = QAction(&#34;&amp;Load File&#34;, self)
        loadFile.setShortcut(&#34;Ctrl+L&#34;)
        loadFile.setStatusTip(&#39;Load File&#39;)
        loadFile.triggered.connect(self.file_load)
        getSettings = QAction(&#34;Get settings&#34;, self)
        getSettings.triggered.connect(self.get_all_settings)
        fileMenu.addAction(saveFile)
        fileMenu.addAction(loadFile)
        fileMenu.addAction(getSettings)

        self.screen_width = width
        self.screen_height = height
        self.setGeometry(width * 0.125, height * 0.125,
                         width * 0.75, height * 0.75)
        self.setWindowTitle(TITLE_STR)
        self.tab_widget = TabWidget(self)
        self.setCentralWidget(self.tab_widget)

        self.curve_manager = AirfoilManager(self)
        self.tab_widget.add_tab(self.curve_manager, &#34;Airfoil management&#34;)

        self.wind_turbine_properties = WindTurbineProperties(self)
        self.tab_widget.add_tab(self.wind_turbine_properties, &#34;Turbine info&#34;)

        self.analysis = Analysis(self)
        self.tab_widget.add_tab(self.analysis, &#34;Analysis&#34;)

        self.getter = ThreadGetter(self)

        self.optimization = Optimization(self)
        self.tab_widget.add_tab(self.optimization, &#34;Optimization&#34;)

        self.running = False
        self.manager = Manager()
        self.set_all_settings(SET_INIT)

        create_folder(&#34;foils&#34;)  # Used by XFoil

        self.show()

    def set_title(self):
        s = self.wind_turbine_properties.name.text()
        if s == &#34;&#34;:
            self.setWindowTitle(TITLE_STR)
        else:
            self.setWindowTitle(TITLE_STR + &#34; - &#34; + s)

    def file_save(self):
        name = QFileDialog.getSaveFileName(self, &#39;Save File&#39;)[0]
        if name != &#34;&#34;:
            file = open(name, &#39;w&#39;)
            d = self.get_all_settings()
            d_to_save = fltr(d, (float, int, list, str, bool, numpy.ndarray))
            json_d = json.dumps(d_to_save)
            file.write(json_d)
            file.close()

    def file_load(self):
        file_path = QFileDialog.getOpenFileName(self, &#34;Load File&#34;)[0]
        if file_path != &#34;&#34;:
            with open(file_path, &#34;r&#34;) as fp:
                data = json.load(fp)
            self.set_all_settings(data)
        self.analysis.clear()
        self.optimization.clear()
        self.set_title()

    def get_all_settings(self):

        try:
            valid_foils = list(self.curve_manager.get_settings()[
                &#34;airfoils&#34;].keys()) + [&#34;transition&#34;, &#34;Transition&#34;]
            properties = self.wind_turbine_properties.get_settings()
            settings = self.analysis.get_settings()
            opt_settings = self.optimization.get_settings()
            curve_manager_settings = self.curve_manager.get_settings()

            out = {**properties, **settings, **opt_settings, **curve_manager_settings}
            _r = out[&#34;r&#34;]
            _c = out[&#34;c&#34;]
            _theta = out[&#34;theta&#34;]
            _foils = out[&#34;foils&#34;]
            r, c, theta, foils, dr = interpolate_geom(
                _r, _c, _theta, _foils, out[&#34;num_interp&#34;], out[&#34;linspace_interp&#34;])
            out[&#34;r&#34;], out[&#34;c&#34;], out[&#34;theta&#34;], out[&#34;foils&#34;], out[&#34;dr&#34;] = r, c, theta, foils, dr
            out[&#34;r_in&#34;], out[&#34;c_in&#34;], out[&#34;theta_in&#34;], out[&#34;foils_in&#34;] = _r, _c, _theta, _foils

            return out
        except Exception as e:
            msg = QMessageBox()
            msg.setIcon(QMessageBox.Warning)
            msg.setText(&#34;Error while getting settings&#34;)
            msg.setDetailedText(str(e))
            msg.exec_()
            print(e)
            return None

    # noinspection PyBroadException
    def set_all_settings(self, inp_dict, suppress=True):
        try:
            self.analysis.set_settings(inp_dict)
        except:
            print(&#34;Error setting analysis settings!&#34;)
            if not suppress:
                raise
        try:
            self.optimization.set_settings(inp_dict)
        except:
            print(&#34;Error setting optimization settings!&#34;)
            if not suppress:
                raise
        try:
            self.wind_turbine_properties.set_settings(inp_dict)
        except:
            print(&#34;Error setting wind turbine properties settings!&#34;)
            if not suppress:
                raise
        try:
            self.curve_manager.set_settings(inp_dict)
        except Exception as e:
            print(&#34;Error setting curve manager settings!&#34;)
            if not suppress:
                raise

    def get_input_params(self):
        settings = self.get_all_settings()
        if settings == None:
            return None
        self.return_print = self.manager.list([])
        self.return_results = self.manager.list([])
        self.end_of_file = False
        inp_params = {**settings, &#34;return_print&#34;: self.return_print, &#34;return_results&#34;: self.return_results,
                      &#34;EOF&#34;: self.end_of_file}
        return inp_params

    def set_buttons_running(self):
        self.analysis.buttonRun.setEnabled(False)
        self.optimization.buttonAngles.setEnabled(False)
        self.optimization.buttonBoth.setEnabled(False)
        self.optimization.buttonOptimalPitch.setEnabled(False)
        self.analysis.buttonStop.setEnabled(True)
        self.optimization.buttonStop.setEnabled(True)

    def set_buttons_await(self):
        self.analysis.buttonRun.setEnabled(True)
        self.optimization.buttonAngles.setEnabled(True)
        self.optimization.buttonBoth.setEnabled(True)
        self.optimization.buttonOptimalPitch.setEnabled(True)
        self.analysis.buttonStop.setEnabled(False)
        self.optimization.buttonStop.setEnabled(False)


class WindTurbineProperties(QWidget):
    def __init__(self, parent=None):
        super(WindTurbineProperties, self).__init__(parent)

        self.main = self.parent()

        grid = QGridLayout()
        self.setLayout(grid)

        left = QWidget()
        fbox = QFormLayout()
        left.setLayout(fbox)

        self.table_properties = Table()
        self.table_properties.createEmpty(4, 30)
        self.table_properties.set_labels(
            [&#34;r [m]&#34;, &#34;c [m]&#34;, &#34;theta [deg]&#34;, &#34;airfoil&#34;])

        grid.addWidget(left, 1, 1)
        grid.addWidget(self.table_properties, 1, 2)

        _name = QLabel(&#34;Turbine Name&#34;)
        self.name = QLineEdit()
        fbox.addRow(_name, self.name)
        self.name.textEdited.connect(self.main.set_title)

        _Rhub = QLabel(&#34;Hub radius [m]&#34;)
        self.Rhub = QLineEdit()
        self.Rhub.setText(&#34;0.1&#34;)
        fbox.addRow(_Rhub, self.Rhub)

        _R = QLabel(&#34;Tip radius [m]&#34;)
        self.R = QLineEdit()
        self.R.setText(&#34;0.776&#34;)
        fbox.addRow(_R, self.R)

        _B = QLabel(&#34;Number of blades&#34;)
        self.B = QLineEdit()
        self.B.setText(&#34;5&#34;)
        fbox.addRow(_B, self.B)

        self.export_button = QPushButton(&#34;Export curve data&#34;)
        self.export_button.clicked.connect(self.export)
        fbox.addRow(&#34;Export:&#34;, self.export_button)

        self.flip_turning_direction = QCheckBox()
        fbox.addRow(&#34;Flip turning direction&#34;, self.flip_turning_direction)

        self.propeller_geom = QCheckBox()
        fbox.addRow(&#34;Propeller&#34;, self.propeller_geom)

    def get_settings(self):
        out_properties = {&#34;Rhub&#34;: to_float(self.Rhub.text()), &#34;R&#34;: to_float(self.R.text()), &#34;B&#34;: int(self.B.text()),
                          &#34;turbine_name&#34;: self.name.text(), }
        geom_array = self.table_properties.get_values()
        r, c, theta, foils = [], [], [], []
        for row in geom_array:
            if row[0] != &#34;&#34; and row[1] != &#34;&#34; and row[2] != &#34;&#34;:
                r.append(to_float(row[0]))
                c.append(to_float(row[1]))
                theta.append(to_float(row[2]))
                foils.append(row[3])
        out_properties[&#34;r&#34;] = numpy.array(r)
        out_properties[&#34;c&#34;] = numpy.array(c)
        out_properties[&#34;theta&#34;] = numpy.array(theta)
        out_properties[&#34;foils&#34;] = foils
        return out_properties

    def set_settings(self, dict_settings):
        if &#34;Rhub&#34; in dict_settings:
            t = str(dict_settings[&#34;Rhub&#34;])
            self.Rhub.setText(t)
        if &#34;R&#34; in dict_settings:
            t = str(dict_settings[&#34;R&#34;])
            self.R.setText(t)
        if &#34;B&#34; in dict_settings:
            t = str(dict_settings[&#34;B&#34;])
            self.B.setText(t)
        if &#34;r_in&#34; in dict_settings and &#34;c_in&#34; in dict_settings and &#34;theta_in&#34; in dict_settings and &#34;foils_in&#34; in dict_settings:
            _array = []
            for r in range(len(dict_settings[&#34;r_in&#34;])):
                _r = dict_settings[&#34;r_in&#34;][r]
                _c = dict_settings[&#34;c_in&#34;][r]
                _theta = dict_settings[&#34;theta_in&#34;][r]
                _f = dict_settings[&#34;foils_in&#34;][r]
                _array.append([_r, _c, _theta, _f])
            self.table_properties.createTable(_array)
        if &#34;turbine_name&#34; in dict_settings:
            t = str(dict_settings[&#34;turbine_name&#34;])
            self.name.setText(t)
        else:
            self.name.setText(&#34;&#34;)

    def export(self):
        print(&#34;Getting settings...&#34;)
        SET_INIT = self.parent().parent().parent().get_all_settings()
        if SET_INIT == None:
            return
        data = create_3d_blade(SET_INIT, self.flip_turning_direction.isChecked(
        ), self.propeller_geom.isChecked())
        w = MatplotlibWindow(self)
        w.ax = w.figure.add_subplot(111, projection=&#34;3d&#34;)
        w.ax.scatter(data[&#34;X&#34;], data[&#34;Y&#34;], data[&#34;Z&#34;])
        X, Y, Z = np.array(data[&#34;X&#34;]), np.array(data[&#34;Y&#34;]), np.array(data[&#34;Z&#34;])
        max_range = np.array(
            [X.max()-X.min(), Y.max()-Y.min(), Z.max()-Z.min()]).max() / 2.0
        mid_x = (X.max()+X.min()) * 0.5
        mid_y = (Y.max()+Y.min()) * 0.5
        mid_z = (Z.max()+Z.min()) * 0.5
        w.ax.set_xlim(mid_x - max_range, mid_x + max_range)
        w.ax.set_ylim(mid_y - max_range, mid_y + max_range)
        w.ax.set_zlim(mid_z - max_range, mid_z + max_range)
        # w.ax.set_aspect(&#34;equal&#34;)

        create_folder(&#34;export&#34;)
        folder_path = os.path.join(&#34;export&#34;, SET_INIT[&#34;turbine_name&#34;])
        create_folder(folder_path)

        filenames = []
        print(&#34;Exporting... (and converting m to mm)&#34;)
        for z, x_data, y_data in data[&#34;data&#34;]:
            print(&#34;Exporting z=&#34;+str(z), &#34;[m]&#34;)
            z = z*1e3  # in mm
            file_name = os.path.join(folder_path, &#34;z_%s.txt&#34; % z)
            filenames.append(os.path.join(os.getcwd(), file_name))
            # print(file_name)
            f = open(os.path.join(folder_path, &#34;z_%s.txt&#34; % z), &#34;w&#34;)
            for x, y in zip(x_data, y_data):
                x, y = x*1e3, y*1e3  # in mm
                f.write(&#34;%s\t%s\t%s\n&#34; % (x, y, z))
            f.close()
        print(&#34;Filenames:&#34;, filenames)
        macro_text = create_macro_text(filenames)

        print(&#34;&#39;===============MACRO START==================&#34;)
        print(macro_text)
        print(&#34;&#39;===============MACRO   END==================&#34;)


class AirfoilManager(QWidget):
    # popup_close = pyqtSignal(str)
    emitter = pyqtSignal(str)

    def __init__(self, parent=None):
        super(AirfoilManager, self).__init__(parent)

        self.main = self.parent()

        self.grid = QGridLayout()
        self.setLayout(self.grid)

        self.tab_widget = TabWidget(self)
        self.grid.addWidget(self.tab_widget, 2, 0)

        self.upper_widget = QWidget()
        self.upper_layout = QGridLayout()
        self.upper_widget.setLayout(self.upper_layout)
        self.grid.addWidget(self.upper_widget, 1, 0)

        self.button_add_foil = QPushButton(&#34;Add airfoil&#34;)
        self.button_add_foil.clicked.connect(self.add_foil_popup)
        self.button_remove_foil = QPushButton(&#34;Remove foil&#34;)
        self.button_remove_foil.clicked.connect(
            self.tab_widget.remove_current_tab)
        self.button_rename_foil = QPushButton(&#34;Rename foil&#34;)
        self.button_rename_foil.clicked.connect(self.rename_foil_popup)
        self.button_get_settings = QPushButton(&#34;get settings&#34;)
        self.button_get_settings.clicked.connect(self.get_settings)

        self.upper_layout.addWidget(self.button_add_foil, 0, 1)
        self.upper_layout.addWidget(self.button_remove_foil, 0, 2)
        self.upper_layout.addWidget(self.button_rename_foil, 0, 3)
        self.upper_layout.addWidget(self.button_get_settings, 0, 4)

    def add_foil_popup(self):
        self.emitter.connect(self.add_foil)
        self.p = PopupText(self, &#34;foil name&#34;, &#34;airfoil_name&#34;,
                           self.emitter, &#34;Add foil&#34;)
        self.p.setGeometry(QRect(100, 100, 400, 200))
        self.p.show()

    def add_foil(self, string):
        c = Airfoils(string, self)
        self.tab_widget.add_tab(c, string)

    def rename_foil_popup(self):
        self.emitter.connect(self.rename_foil)
        self.p = PopupText(self, &#34;foil name&#34;, self.tab_widget.current_tab_name(
        ), self.emitter, &#34;Rename foil&#34;)
        self.p.setGeometry(QRect(100, 100, 400, 200))
        self.p.show()

    def rename_foil(self, string):
        self.tab_widget.rename_current_tab(string)  # self.tab_widget.tabs

    def get_settings(self):
        out = {}
        i = 0

        # TODO Dont rely on name being set correctly in n!
        for w, n in self.tab_widget.tabs:
            out[n] = w.get_settings()
            i += 1

        return {&#34;airfoils&#34;: out}

    def set_settings(self, dict_settings):
        self.tab_widget.remove_all_tabs()
        if &#34;airfoils&#34; in dict_settings:
            if len(dict_settings[&#34;airfoils&#34;]) &gt; 0:
                for c_name, c_dict in dict_settings[&#34;airfoils&#34;].items():
                    curve_widget = Airfoils(c_name, self)
                    try:
                        curve_widget.set_settings(c_dict)
                        self.tab_widget.add_tab(curve_widget, c_name)
                    except:
                        pass


class PopupText(QWidget):
    def __init__(self, parent=None, message=&#34;message&#34;, default_str=&#34;&#34;, emitter=None, title=&#34;Text popup&#34;, text_input=True):
        QWidget.__init__(self)

        # self.setTitle(title)
        self.emitter = emitter

        self.layout = QGridLayout()
        self.setLayout(self.layout)

        self.message = QLabel(message)

        self.layout.addWidget(self.message, 0, 0)

        if text_input:
            self.inp = QLineEdit()
            self.inp.setText(default_str)
            self.layout.addWidget(self.inp, 1, 0)

        self.button = QPushButton(&#34;OK&#34;)
        self.button.clicked.connect(self.send_signal)
        self.layout.addWidget(self.button, 2, 0)

    def send_signal(self):
        if self.emitter != None:
            self.emitter.emit(self.inp.text())
            self.emitter.disconnect()
        self.close()


class Airfoils(QWidget):
    def __init__(self, airfoil_name, parent=None):
        super(Airfoils, self).__init__(parent)

        self.curves = Curves()

        self.viewer = CurveViewer(self)

        self.airfoil_name = airfoil_name

        grid = QGridLayout()
        self.setLayout(grid)

        self.interp_function_cl = None
        self.interp_function_cd = None

        self.table_dat = Table()
        self.table_dat.createEmpty(2, 50)
        self.table_dat.set_labels([&#34;x&#34;, &#34;y&#34;])
        grid.addWidget(self.table_dat, 1, 1)

        self.plt = plt.figure(figsize=(10, 5))
        self.canvas = FigureCanvas(self.plt)
        toolbar = NavigationToolbar(self.canvas, self)
        grid.addWidget(self.canvas, 1, 2)

        self.ax = self.plt.add_subplot(111)
        grid.addWidget(toolbar, 2, 2)

        self.buttonRefresh = QPushButton(&#34;Refresh curve&#34;)
        grid.addWidget(self.buttonRefresh, 2, 1)

        self.buttonRefresh.clicked.connect(self.draw_airfoil)
        self.link = QLineEdit(&#34;link (airfoiltools.com)&#34;)
        grid.addWidget(self.link, 3, 1)

        #self.button_generate_interp = QPushButton(&#34;Generate interp functions&#34;)
        # self.button_generate_interp.clicked.connect(self.generate_interp_functions)
        #grid.addWidget(self.button_generate_interp, 3, 2)

        self.button_open_viewer = QPushButton(&#34;Open Curve Viewer&#34;)
        self.button_open_viewer.clicked.connect(self.open_viewer)
        grid.addWidget(self.button_open_viewer, 4, 2)

        self.button_generate_curves_xfoil = QPushButton(
            &#34;Generate xfoil curves [debug]&#34;)
        self.button_generate_curves_xfoil.clicked.connect(
            self.generate_curves_xfoil)
        grid.addWidget(self.button_generate_curves_xfoil, 4, 1)

        self.button_generate_curves_link = QPushButton(
            &#34;Generate curves from link&#34;)
        self.button_generate_curves_link.clicked.connect(
            self.generate_curves_link)
        grid.addWidget(self.button_generate_curves_link, 5, 1)

        self.button_visualize = QPushButton(&#34;Create curve visualization&#34;)
        self.button_visualize.clicked.connect(self.visualize)
        grid.addWidget(self.button_visualize, 5, 2)

        self.get_centroid_button = QPushButton(&#34;Calculate centroid&#34;)
        self.get_centroid_button.clicked.connect(self.calculate_centroid)
        grid.addWidget(self.get_centroid_button, 6, 1)

        self.centroid_widget = QWidget()
        self.centroid_grid = QGridLayout()
        self.centroid_widget.setLayout(self.centroid_grid)
        grid.addWidget(self.centroid_widget, 6, 2)

        self.centroid_x_edit = QLineEdit()
        self.centroid_y_edit = QLineEdit()

        self.centroid_grid.addWidget(self.centroid_x_edit, 1, 1)
        self.centroid_grid.addWidget(self.centroid_y_edit, 1, 2)

    def visualize(self):
        print(&#34;Visualizing&#34;)
        data = self.curves.gather_curves()

        re = data[:, 0]
        alpha = data[:, 2]
        cl = data[:, 3]
        cd = data[:, 4]

        re_min, re_max = data[:, 0].min(), data[:, 0].max()
        alpha_min, alpha_max = data[:, 2].min(), data[:, 2].max()

        x, y = np.linspace(re_min, re_max, 10), np.linspace(
            alpha_min, alpha_max, 180)
        xi, yi = np.meshgrid(x, y)
        xi, yi = xi.flatten(), yi.flatten()
        z_1 = interp_at(re, alpha, cl, xi, yi)
        z_2 = interp_at(re, alpha, cd, xi, yi)
        w = MatplotlibWindow(self)
        w.ax = w.figure.add_subplot(111, projection=&#34;3d&#34;)
        #w.ax.scatter(xi, yi, z_1)
        #w.ax.scatter(xi, yi, z_2)
        p = w.ax.plot_trisurf(xi, yi, z_1, cmap=cm.coolwarm)
        w.ax.set_xlabel(&#34;Reynolds&#34;, fontsize=15, labelpad=20)
        w.ax.set_ylabel(r&#39;$\alpha$ [°]&#39;, fontsize=15, labelpad=20)
        w.ax.set_zlabel(&#34;Cl&#34;, fontsize=15, labelpad=20)
        w.ax.xaxis.set_tick_params(labelsize=12)
        w.ax.yaxis.set_tick_params(labelsize=12)
        w.ax.zaxis.set_tick_params(labelsize=12)
        bar = w.figure.colorbar(p)
        bar.ax.set_xlabel(&#39;Cl&#39;, fontsize=15, labelpad=20)

        w2 = MatplotlibWindow(self)
        w2.ax = w2.figure.add_subplot(111, projection=&#34;3d&#34;)
        #w.ax.scatter(xi, yi, z_1)
        #w.ax.scatter(xi, yi, z_2)
        p = w2.ax.plot_trisurf(xi, yi, z_2, cmap=cm.coolwarm)
        w2.ax.set_xlabel(&#34;Reynolds&#34;, fontsize=15, labelpad=20)
        w2.ax.set_ylabel(r&#39;$\alpha$ [°]&#39;, fontsize=15, labelpad=20)
        w2.ax.set_zlabel(&#34;Cd&#34;, fontsize=15, labelpad=20)
        w2.ax.xaxis.set_tick_params(labelsize=12)
        w2.ax.yaxis.set_tick_params(labelsize=12)
        w2.ax.zaxis.set_tick_params(labelsize=12)
        bar2 = w2.figure.colorbar(p)
        bar2.ax.set_xlabel(&#39;Cd&#39;, fontsize=15, labelpad=20)

    def open_viewer(self):
        print(&#34;opening viewwer&#34;)
        self.viewer.show()
        self.viewer.generate_views()

    def generate_interp_functions(self):
        data = self.gather_curves()
        x, y = self.get_x_y()
        self.interp_function_cl, self.interp_function_cd = get_cl_cd_interpolation_function(
            data, x, y)

    def generate_curves_xfoil(self):
        print(&#34;Generating xfoil curves&#34;)
        data = generate_polars_data(self.airfoil_name + &#34;.dat&#34;)
        self.populate_curve_list(data)
        print(&#34;Done&#34;)

    def generate_curves_link(self):
        print(&#34;Scraping from link...&#34;)
        data = scrape_data(self.link.text())
        self.populate_curve_list(data)
        print(&#34;Done&#34;)

    def populate_curve_list(self, data):
        self.curves.curve_list = []
        x, y = self.get_x_y()
        Re_list = np.unique(data[:, 0])
        ncrit_list = np.unique(data[:, 1])
        ncrit_selected = np.min(ncrit_list)
        for Re in Re_list:
            rows_with_Re = data[np.in1d(data[:, 0], Re)]
            rows_with_Re = rows_with_Re[np.in1d(
                rows_with_Re[:, 1], ncrit_selected)]
            _alpha = rows_with_Re[:, 2].flatten()
            _cl = rows_with_Re[:, 3].flatten()
            _cd = rows_with_Re[:, 4].flatten()
            c = Curve()
            c.create(x=x, y=y, Re=Re, ncrit=ncrit_selected,
                     alpha=_alpha, cl=_cl, cd=_cd)
            self.curves.add(c)

    def draw_airfoil(self):
        self.ax.clear()
        x_values = []
        y_values = []
        array_dat = self.table_dat.get_values()
        for r in array_dat:
            if r[0] != &#34;&#34; and r[1] != &#34;&#34;:
                # noinspection PyBroadException
                try:
                    _x = to_float(r[0])
                    _y = to_float(r[1])
                except:
                    print(&#34;Error drawing airfoil because _x or _y isn&#39;t a float.&#34;)
                    return
                x_values.append(_x)
                y_values.append(_y)
        self.ax.set_xlim(0, 1)
        self.ax.set_ylim(-0.5, 0.5)
        self.ax.plot(x_values, y_values)
        try:
            centroid_x = float(self.centroid_x_edit.text())
            centroid_y = float(self.centroid_y_edit.text())
            self.ax.plot(centroid_x, centroid_y, &#34;r+&#34;)
        except Exception as e:
            msg = QMessageBox()
            msg.setIcon(QMessageBox.Warning)
            msg.setText(&#34;Error while getting settings&#34;)
            msg.setDetailedText(str(e))
            msg.exec_()
            print(e)

        self.plt.canvas.draw()

    def get_max_thickness(self):
        x = []
        y = []
        array_dat = self.table_dat.get_values()
        for r in array_dat:
            if r[0] != &#34;&#34; and r[1] != &#34;&#34;:
                _x = to_float(r[0])
                _y = to_float(r[1])
                x.append(_x)
                y.append(_y)
        if len(y) &gt; 0:
            y_max = numpy.max(y)
            y_min = numpy.min(y)
            thickness = (abs(y_max) + abs(y_min)) / 1
            return thickness
        return None

    def get_x_y(self):
        x = []
        y = []

        array_dat = self.table_dat.get_values()
        for r in array_dat:
            if r[0] != &#34;&#34; and r[1] != &#34;&#34;:
                _x = to_float(r[0])
                _y = to_float(r[1])
                x.append(_x)
                y.append(_y)
        return x, y

    def calculate_centroid(self):
        foil_x, foil_y = self.get_x_y()
        x, y = get_centroid_coordinates(foil_x, foil_y)
        self.centroid_x_edit.setText(str(x))
        self.centroid_y_edit.setText(str(y))
        return x, y

    def get_settings(self):
        x, y = self.get_x_y()
        try:
            centroid_x = float(self.centroid_x_edit.text())
            centroid_y = float(self.centroid_y_edit.text())
            out = {&#34;x&#34;: x, &#34;y&#34;: y, &#34;max_thickness&#34;: self.get_max_thickness(), &#34;link&#34;: self.link.text(),
                   &#34;interp_function_cl&#34;: self.interp_function_cl, &#34;interp_function_cd&#34;: self.interp_function_cd,
                   &#34;curves&#34;: self.curves.save_curves(), &#34;gathered_curves&#34;: self.curves.gather_curves(),
                   &#34;centroid_x&#34;: centroid_x, &#34;centroid_y&#34;: centroid_y}
            return out
        except Exception as e:
            raise Exception(&#34;Error in airfoil %s... (%s)&#34; %
                            (self.airfoil_name, str(e)))

    def set_settings(self, dict_settings):
        array_dat = []
        if len(dict_settings[&#34;x&#34;]) &gt; 0 and len(dict_settings[&#34;y&#34;]) &gt; 0:
            for r in range(len(dict_settings[&#34;x&#34;])):
                array_dat.append([str(dict_settings[&#34;x&#34;][r]),
                                  str(dict_settings[&#34;y&#34;][r])])
            self.table_dat.createTable(array_dat)
            self.calculate_centroid()
            self.draw_airfoil()

        self.link.setText(dict_settings[&#34;link&#34;])
        self.curves.load_curves(dict_settings[&#34;curves&#34;])


class MatplotlibWindow(QWidget):
    def __init__(self, parent=None, curve=None):
        super(MatplotlibWindow, self).__init__(None)
        self.layout = QGridLayout()
        self.setLayout(self.layout)
        self.figure = plt.figure(figsize=(10, 5))
        self.canvas = FigureCanvas(self.figure)
        self.canvas.setMinimumSize(500, 500)
        self.toolbar = NavigationToolbar(self.canvas, self)
        self.layout.addWidget(self.canvas)
        self.layout.addWidget(self.toolbar)
        # self.ax = self.figure.add_subplot(111)
        self.show()


class Curves:
    def __init__(self):
        self.curve_list = []

    def add(self, curve):
        self.curve_list.append(curve)

    def save_curves(self):
        out_list = []
        for c in self.curve_list:
            data_curve = c.save_curve()
            out_list.append(data_curve)
        return out_list

    def load_curves(self, out):
        self.curve_list = []
        for data_curve in out:
            c = Curve()
            c.load_curve(data_curve)
            self.curve_list.append(c)

    def gather_curves(self):
        out = []
        for curve in self.curve_list:
            alpha, cl, cd = curve.get_combined_curve()
            # print(alpha,cl,cd)
            for i in range(len(alpha)):
                Re = curve.Re
                ncrit = curve.ncrit
                _alpha = alpha[i]
                _cl = cl[i]
                _cd = cd[i]

                out.append([Re, ncrit, _alpha, _cl, _cd])
        out = np.array(out)
        return out


class Curve:
    def __init__(self):
        self.x = None
        self.y = None
        self.Re = None
        self.ncrit = None
        self.alpha = None
        self.cl = None
        self.cd = None
        self.A = None
        self.B = None
        self.Am = None
        self.Bm = None
        self.m_CD90 = None
        self.slope = None

    def create(self, x, y, Re, ncrit, alpha, cl, cd):
        self.x = x
        self.y = y
        self.Re = Re
        self.ncrit = 0.0  # doesnt make any difference for now
        self.alpha = alpha
        self.cl = cl
        self.cd = cd
        self.A = 5
        self.B = 5
        self.Am = 5
        self.Bm = 5
        self.m_CD90 = 2.0
        self.slope = 0.106

    def get_cl_curve(self):
        return self.alpha_cl, self.cl

    def get_extrapolated_curve(self):
        M = Montgomerie(x=self.x, y=self.y, alpha=self.alpha, Cl=self.cl, Cd=self.cd, Re=self.Re, A=self.A, Am=self.Am,
                        B=self.B, Bm=self.Bm, m_CD90=self.m_CD90, slope=self.slope)
        alpha, cl, cd = M.calculate_extrapolation()
        return alpha, cl, cd

    def get_combined_curve(self):
        M = Montgomerie(x=self.x, y=self.y, alpha=self.alpha, Cl=self.cl, Cd=self.cd, Re=self.Re, A=self.A, Am=self.Am,
                        B=self.B, Bm=self.Bm, m_CD90=self.m_CD90, slope=self.slope)
        _alpha, _cl, _cd = M.calculate_extrapolation()
        cl_out, cd_out = [], []
        f_cl = interp1d(self.alpha, self.cl, bounds_error=True)
        f_cd = interp1d(self.alpha, self.cd, bounds_error=True)
        for i in range(len(_alpha)):
            # x.append(self.Re)
            # y.append(m_Alpha[i])
            a = _alpha[i]
            try:
                cl = f_cl(a)
            except ValueError:
                cl = _cl[i]
            # try:
            #     cd = f_cd(a)
            # except ValueError:
            #     cd = _cd[i]
            # tukaj vzamem  samo Montgomerie interpolacijo cd, za lazjo interpolacijo
            cd = _cd[i]
            cl_out.append(cl)
            cd_out.append(cd)
        return _alpha, cl_out, cd_out

    def save_curve(self):
        out = {
            &#34;x&#34;: list(self.x),
            &#34;y&#34;: list(self.y),
            &#34;Re&#34;: self.Re,
            &#34;ncrit&#34;: self.ncrit,
            &#34;alpha&#34;: list(self.alpha),
            &#34;cl&#34;: list(self.cl),
            &#34;cd&#34;: list(self.cd),
            &#34;A&#34;: self.A,
            &#34;B&#34;: self.B,
            &#34;Am&#34;: self.Am,
            &#34;Bm&#34;: self.Bm,
            &#34;m_CD90&#34;: self.m_CD90,
            &#34;slope&#34;: self.slope
        }
        return out

    def load_curve(self, out):
        self.x = out[&#34;x&#34;]
        self.y = out[&#34;y&#34;]
        self.Re = out[&#34;Re&#34;]
        self.ncrit = out[&#34;ncrit&#34;]
        self.alpha = out[&#34;alpha&#34;]
        self.cl = out[&#34;cl&#34;]
        self.cd = out[&#34;cd&#34;]
        self.A = out[&#34;A&#34;]
        self.B = out[&#34;B&#34;]
        self.Am = out[&#34;Am&#34;]
        self.Bm = out[&#34;Bm&#34;]
        self.m_CD90 = out[&#34;m_CD90&#34;]
        self.slope = out[&#34;slope&#34;]


class CurveViewer(QWidget):
    def __init__(self, parent=None):
        super(CurveViewer, self).__init__(None)
        self.resize(1600, 768)
        self.parent = parent
        self.grid = QGridLayout()
        self.setLayout(self.grid)
        self.button = QPushButton(&#34;Close&#34;)
        self.grid.addWidget(self.button, 1, 1)
        self.button.clicked.connect(self.close)
        self.button_refresh = QPushButton(&#34;Refresh&#34;)
        self.grid.addWidget(self.button_refresh, 1, 2)
        self.button_refresh.clicked.connect(self.generate_views)

        self.bottom = QWidget()
        # self.fbox = QFormLayout()
        self.grid_curves = QGridLayout()
        self.bottom.setLayout(self.grid_curves)

        self.scroll_area = QtWidgets.QScrollArea()
        self.scroll_widget = QtWidgets.QWidget()
        self.scroll_widget_layout = QtWidgets.QVBoxLayout()

        self.scroll_widget.setLayout(self.scroll_widget_layout)
        self.scroll_area.setWidget(self.bottom)
        self.scroll_area.setWidgetResizable(True)
        self.grid.addWidget(self.scroll_area, 2, 1, 2, 2)

        # self.generate_views()

    def generate_views(self):

        # delete stuff already here
        for i in reversed(range(self.grid_curves.count())):
            self.grid_curves.itemAt(i).widget().setParent(None)

        # for i in range(10):
        #    control = CurveControl(self,None)
        #    self.grid_curves.addWidget(control)

        for curve in self.parent.curves.curve_list:
            label = QLabel(&#34;Re:&#34; + str(curve.Re) + &#34;:&#34;)
            control = CurveControl(self, curve)
            control.update()
            self.grid_curves.addWidget(label)
            self.grid_curves.addWidget(control)


class CurveControl(QWidget):
    def __init__(self, parent=None, curve=None):
        super(CurveControl, self).__init__(parent)
        # self.setMinimumSize(300,400)
        self.parent = parent

        self.layout = QGridLayout()
        self.setLayout(self.layout)

        self.curve = curve

        self.right = QWidget()
        self.right_layout = QFormLayout()
        self.right.setLayout(self.right_layout)

        self.A = QLineEdit(str(self.curve.A))
        self.B = QLineEdit(str(self.curve.B))
        self.Am = QLineEdit(str(self.curve.Am))
        self.Bm = QLineEdit(str(self.curve.Bm))

        self.A = QSlider(Qt.Horizontal)
        self.A.setMinimum(-10)
        self.A.setMaximum(30)
        self.A.setValue(self.curve.A)
        self.A.setTickPosition(QSlider.TicksBelow)
        self.A.setTickInterval(1)
        self.A.valueChanged.connect(self.update)

        self.B = QSlider(Qt.Horizontal)
        self.B.setMinimum(1)
        self.B.setMaximum(100)
        self.B.setValue(self.curve.B)
        self.B.setTickPosition(QSlider.TicksBelow)
        self.B.setTickInterval(1)
        self.B.valueChanged.connect(self.update)

        self.Am = QSlider(Qt.Horizontal)
        self.Am.setMinimum(1)
        self.Am.setMaximum(80)
        self.Am.setValue(self.curve.Am)
        self.Am.setTickPosition(QSlider.TicksBelow)
        self.Am.setTickInterval(1)
        self.Am.valueChanged.connect(self.update)

        self.Bm = QSlider(Qt.Horizontal)
        self.Bm.setMinimum(1)
        self.Bm.setMaximum(70)
        self.Bm.setValue(self.curve.Bm)
        self.Bm.setTickPosition(QSlider.TicksBelow)
        self.Bm.setTickInterval(1)
        self.Bm.valueChanged.connect(self.update)

        self.m_CD90 = QLineEdit(str(self.curve.m_CD90))
        self.m_CD90.textChanged.connect(self.update)
        self.slope = QLineEdit(str(self.curve.slope))
        self.slope.textChanged.connect(self.update)

        self.right_layout.addRow(&#34;A&#34;, self.A)
        self.right_layout.addRow(&#34;B&#34;, self.B)
        self.right_layout.addRow(&#34;A-&#34;, self.Am)
        self.right_layout.addRow(&#34;B-&#34;, self.Bm)
        self.right_layout.addRow(&#34;CD@90°&#34;, self.m_CD90)
        self.right_layout.addRow(&#34;Slope&#34;, self.slope)

        self.layout.addWidget(self.right, 1, 2)

        self.left = QWidget()
        self.left_layout = QGridLayout()
        self.left.setLayout(self.left_layout)

        self.figure = plt.figure(figsize=(10, 5))
        self.canvas = FigureCanvas(self.figure)
        self.canvas.setMinimumSize(500, 500)
        self.toolbar = NavigationToolbar(self.canvas, self)
        self.ax = self.figure.add_subplot(111)
        self.left_layout.addWidget(self.canvas)
        self.left_layout.addWidget(self.toolbar)

        self.layout.addWidget(self.left, 1, 1)

        self.button_update = QPushButton(&#34;update&#34;)
        self.button_update.clicked.connect(self.draw_extrapolation)
        self.left_layout.addWidget(self.button_update)

        # self.draw_base()

        self.show()

    def clear(self):
        self.ax.cla()

    def draw_base(self):
        self.ax.plot(self.curve.alpha, self.curve.cl)
        self.ax.plot(self.curve.alpha, self.curve.cd, &#34;o-&#34;)
        self.canvas.draw()

    def draw_extrapolation(self):
        self.clear()

        self.draw_base()

        alpha, cl, cd = self.curve.get_extrapolated_curve()
        self.ax.plot(alpha, cl, &#34;g.&#34;)
        self.ax.plot(alpha, cd, &#34;r.&#34;)
        self.canvas.draw()

    def update(self):
        self.curve.A = int(self.A.value())
        self.curve.B = int(self.B.value())
        self.curve.Am = int(self.Am.value())
        self.curve.Bm = int(self.Bm.value())
        try:
            self.curve.m_CD90 = float(self.m_CD90.text())
            self.curve.slope = float(self.slope.text())
            if self.curve.slope == 0:
                self.curve.slope = 1.0
        except:
            print(&#34;Error in slope or m_CD90&#34;)
        self.draw_extrapolation()


class Analysis(QWidget):
    def __init__(self, parent=None):
        super(Analysis, self).__init__(parent)

        self.main = self.parent()

        self.settings = {&#34;propeller_mode&#34;: False, &#34;tip_loss&#34;: False, &#34;hub_loss&#34;: False, &#34;new_tip_loss&#34;: False,
                         &#34;new_hub_loss&#34;: False, &#34;cascade_correction&#34;: False,
                         &#34;rotational_augmentation_correction&#34;: False, &#34;rotational_augmentation_correction_method&#34;: 1,
                         &#34;mach_number_correction&#34;: False, &#34;max_iterations&#34;: 100, &#34;convergence_limit&#34;: 0.001,
                         &#34;rho&#34;: 1.225, &#34;method&#34;: 10, &#34;linspace_interp&#34;: False, &#34;num_interp&#34;: 25, &#34;v_min&#34;: 3,
                         &#34;v_max&#34;: 20, &#34;v_num&#34;: 10, &#34;rpm_min&#34;: 100, &#34;rpm_max&#34;: 3000, &#34;rpm_num&#34;: 10, &#34;pitch&#34;: 0.0,
                         &#34;relaxation_factor&#34;: 0.3, &#34;print_all&#34;: False, &#34;print_out&#34;: False, &#34;reynolds&#34;: 50000,
                         &#34;fix_reynolds&#34;: False}

        self.settings_to_name = {&#34;propeller_mode&#34;: &#34;Propeller mode&#34;, &#34;print_out&#34;: &#34;Print final iteration data&#34;,
                                 &#34;tip_loss&#34;: &#34;Prandtl tip loss&#34;, &#34;hub_loss&#34;: &#34;Prandtl hub loss&#34;,
                                 &#34;new_tip_loss&#34;: &#34;New tip loss&#34;, &#34;new_hub_loss&#34;: &#34;New hub loss&#34;,
                                 &#34;cascade_correction&#34;: &#34;Cascade correction&#34;, &#34;max_iterations&#34;: &#34;Maximum iterations&#34;,
                                 &#34;convergence_limit&#34;: &#34;Convergence criteria&#34;, &#34;rho&#34;: &#34;Air density [kg/m^3]&#34;,
                                 &#34;method&#34;: &#34;Calculation method&#34;, &#34;v_min&#34;: &#34;Min calc. wind speed [m/s]&#34;,
                                 &#34;v_max&#34;: &#34;Max calc. wind speed [m/s]&#34;, &#34;v_num&#34;: &#34;Number of wind speed points&#34;,
                                 &#34;rpm_min&#34;: &#34;Min calc. RPM [RPM]&#34;, &#34;rpm_max&#34;: &#34;Max calc. RPM [RPM]&#34;,
                                 &#34;rpm_num&#34;: &#34;Number of RPM points&#34;, &#34;relaxation_factor&#34;: &#34;Relaxation factor&#34;,
                                 &#34;print_all&#34;: &#34;Print every iteration [debug]&#34;,
                                 &#34;num_interp&#34;: &#34;Number of sections (interp)&#34;,
                                 &#34;linspace_interp&#34;: &#34;Custom number of sections&#34;,
                                 &#34;rotational_augmentation_correction&#34;: &#34;Rot. augmentation cor.&#34;,
                                 &#34;rotational_augmentation_correction_method&#34;: &#34;Rot. augmentation cor. method&#34;,
                                 &#34;fix_reynolds&#34;: &#34;Fix Reynolds&#34;, &#34;reynolds&#34;: &#34;Reynolds&#34;,
                                 &#34;mach_number_correction&#34;: &#34;Mach number correction&#34;, &#34;pitch&#34;: &#34;Pitch&#34;}

        self.list_settings_for_updating_tsr = [
            &#34;v_min&#34;, &#34;v_max&#34;, &#34;v_num&#34;, &#34;rpm_min&#34;, &#34;rpm_max&#34;, &#34;rpm_num&#34;]

        self.methods_to_names = METHODS_STRINGS

        self.name_to_methods = {v: k for k, v in self.methods_to_names.items()}
        self.name_to_settings = {v: k for k,
                                 v in self.settings_to_name.items()}

        self.grid = QGridLayout()
        self.setLayout(self.grid)

        self.left = QWidget()
        self.fbox = QFormLayout()
        self.left.setLayout(self.fbox)

        self.scroll_area = QtWidgets.QScrollArea()
        self.scroll_widget = QtWidgets.QWidget()
        self.scroll_widget_layout = QtWidgets.QVBoxLayout()

        self.scroll_widget.setLayout(self.scroll_widget_layout)
        self.scroll_area.setWidget(self.left)
        self.scroll_area.setWidgetResizable(True)

        self.grid.addWidget(self.scroll_area, 1, 1)

        self.textEdit = QTextEdit()
        self.textEdit.setReadOnly(True)
        self.grid.addWidget(self.textEdit, 1, 2)

        self.buttonRun = QPushButton(&#34;Run&#34;)

        self.form_list = []
        self.validator = QtGui.QDoubleValidator()

        for key, value in self.settings.items():
            if key == &#34;method&#34;:
                form = QComboBox()
                form.addItems([self.methods_to_names[k]
                               for k, v in self.methods_to_names.items()])
                form.setCurrentIndex(7)
            elif key == &#34;rotational_augmentation_correction_method&#34;:
                form = QComboBox()
                form.addItems([&#34;1&#34;, &#34;2&#34;, &#34;3&#34;, &#34;4&#34;, &#34;5&#34;])
            elif isinstance(value, bool):
                form = QCheckBox()
                form.setTristate(value)
            else:
                form = QLineEdit()
                form.setValidator(self.validator)
                form.textChanged.connect(self.check_state)
                form.textChanged.emit(form.text())
                form.insert(str(value))
                if key in self.list_settings_for_updating_tsr:
                    form.textChanged.connect(self.update_tsr_and_j)
            key_orig = key
            key = self.settings_to_name[key]
            self.fbox.addRow(key, form)
            self.form_list.append([key, form, key_orig])

        self.tsr_string = QLabel(&#34;0&#34;)
        self.J_string = QLabel(&#34;0&#34;)
        self.emptyLabel = QLabel(&#34; &#34;)
        self.buttonRun.clicked.connect(self.run)
        self.buttonClear = QPushButton(&#34;Clear screen&#34;)
        self.buttonClear.clicked.connect(self.clear)
        self.buttonEOF = QCheckBox()
        self.buttonEOF.setChecked(True)
        self.buttonEOFdescription = QLabel(&#34;Scroll to end of screen&#34;)
        self.buttonStop = QPushButton(&#34;Stop&#34;)
        self.buttonStop.clicked.connect(self.terminate)

        self.fbox.addRow(self.emptyLabel, self.buttonRun)
        self.fbox.addRow(self.buttonClear, self.buttonStop)
        self.fbox.addRow(self.buttonEOFdescription, self.buttonEOF)
        self.fbox.addRow(&#34;TSR:&#34;, self.tsr_string)
        self.fbox.addRow(&#34;J:&#34;, self.J_string)

    def update_tsr_and_j(self):
        try:
            s = self.get_settings()
            R = float(self.main.wind_turbine_properties.R.text())
            tsr_min = 2*np.pi*float(s[&#34;rpm_min&#34;])*R/60/float(s[&#34;v_max&#34;])
            tsr_max = 2*np.pi*float(s[&#34;rpm_max&#34;])*R/60/float(s[&#34;v_min&#34;])
            self.tsr_string.setText(&#34;%.2f - %.2f&#34; % (tsr_min, tsr_max))
            J_min = float(s[&#34;v_min&#34;])/(float(s[&#34;rpm_max&#34;])/60*2*R)
            J_max = float(s[&#34;v_max&#34;])/(float(s[&#34;rpm_min&#34;])/60*2*R)
            self.J_string.setText(&#34;%.2f - %.2f&#34; % (J_min, J_max))
        except:
            print(&#34;couldnt update tsr min/max or J min/max&#34;)

    def check_forms(self):
        out = &#34;&#34;
        for n, f, n_short in self.form_list:
            if isinstance(f, QLineEdit):
                state = self.validator.validate(f.text(), 0)[0]
                if state == QtGui.QValidator.Acceptable:
                    pass
                elif state == QtGui.QValidator.Intermediate:
                    out += &#34;Form %s appears not to be valid.\n&#34; % n
                else:
                    out += &#34;Form %s is not of the valid type.\n&#34; % n
        if out == &#34;&#34;:
            return True
        return out

    def check_state(self, *args, **kwargs):
        sender = self.sender()
        validator = sender.validator()
        state = validator.validate(sender.text(), 0)[0]
        if state == QtGui.QValidator.Acceptable:
            color = &#34;#edf5e1&#34;  # green
        elif state == QtGui.QValidator.Intermediate:
            color = &#34;#fff79a&#34;  # yellow
        else:
            color = &#34;#f6989d&#34;  # red
        sender.setStyleSheet(&#34;QLineEdit { background-color: %s }&#34; % color)

    def get_settings(self):
        out_settings = {}
        for name, value, name_short in self.form_list:
            name = self.name_to_settings[name]
            if isinstance(value, QCheckBox):
                value = bool(value.checkState())
            if isinstance(value, QLineEdit):
                value = to_float(value.text())
            if isinstance(value, QComboBox):
                value = int(value.currentIndex())
            out_settings[name] = value
        return out_settings

    def set_settings(self, inp_dict):
        for name_long, item, name in self.form_list:
            if name in inp_dict:
                if isinstance(item, QComboBox):
                    _index = inp_dict[name]
                    if _index &gt;= 0:
                        index = _index
                    else:
                        index = 0
                    item.setCurrentIndex(index)
                elif isinstance(item, QLineEdit):
                    item.setText(str(inp_dict[name]))
                elif isinstance(item, QCheckBox):
                    item.setChecked(inp_dict[name])

    def run(self):
        self.clear()
        check = self.check_forms()
        if check != True:
            msg = QMessageBox()
            msg.setIcon(QMessageBox.Warning)
            msg.setText(&#34;Input validation error.&#34;)
            msg.setDetailedText(check)
            msg.exec_()
            return

        self.main.emitter_add.connect(self.add_text)
        self.main.emitter_done.connect(self.done)

        if not self.main.running:
            self.main.set_buttons_running()
            self.main.running = True
            self.runner_input = self.main.get_input_params()
            if self.runner_input == None:
                print(&#34;No settings fetched... Terminating.&#34;)
                self.terminate()
                return self.done(True)
            self.main.getter.start()
            self.p = Process(target=calculate_power_3d,
                             args=[self.runner_input])
            self.p.start()
        else:
            msg = QMessageBox()
            msg.setIcon(QMessageBox.Warning)
            msg.setText(&#34;Cannot run while existing operation is running&#34;)
            msg.setInformativeText(
                &#34;The program detected that an existing operation is running.&#34;)
            msg.setWindowTitle(&#34;Runtime error&#34;)
            msg.setDetailedText(&#34;Currently tha value MainWindow.running is %s, \
                it should be False.&#34; % str(self.main.running))
            msg.exec_()

    def add_text(self, string):
        self.textEdit.insertPlainText(string)
        if self.buttonEOF.checkState() == 2:
            self.textEdit.moveCursor(QtGui.QTextCursor.End)

    def done(self, terminated=False):
        self.main.emitter_add.disconnect()
        self.main.emitter_done.disconnect()
        self.main.set_buttons_await()
        self.main.running = False
        self.main.getter.__del__()
        if not terminated:
            self.p.join()
            if len(self.main.return_results) &gt; 0:
                results = self.main.return_results[-1]
                if &#34;v&#34; in results:
                    if len(results[&#34;v&#34;]) &gt; 0:
                        inp_params = self.runner_input
                        r = ResultsWindow(
                            self, self.main.screen_width, self.main.screen_width, results, inp_params, )
                    else:
                        print(&#34;Not enough points to print results...&#34;)
                else:
                    print(&#34;No results to print...&#34;)

    def clear(self):
        self.textEdit.clear()

    def terminate(self):
        if hasattr(self, &#34;p&#34;):
            if self.p.is_alive():
                self.p.terminate()
                self.main.running = False
                self.main.getter.__del__()

                # change to self.done(True), if you dont want to see already calculated points
                self.done(False)


class Optimization(QWidget):
    def __init__(self, parent=None):
        super(Optimization, self).__init__(parent)
        self.main = self.parent()

        self.validator = QtGui.QDoubleValidator()
        self.left = QWidget()
        self.textEdit = QTextEdit()
        self.textEdit.setReadOnly(True)

        self.form_list = []

        self.target_speed = QLineEdit()
        self.target_speed.setValidator(self.validator)
        self.target_speed.textChanged.connect(self.check_state)
        self.target_speed.textChanged.emit(self.target_speed.text())
        self._target_speed = QLabel(&#34;Target speed [m/s]&#34;)
        self.form_list.append([self._target_speed, self.target_speed])

        self.target_rpm = QLineEdit()
        self.target_rpm.setValidator(self.validator)
        self.target_rpm.textChanged.connect(self.check_state)
        self.target_rpm.textChanged.emit(self.target_rpm.text())
        self._target_rpm = QLabel(&#34;Target rpm [RPM]&#34;)
        self.form_list.append([self._target_rpm, self.target_rpm])

        self._form = QLabel(&#34;Optimization variable&#34;)
        self.form = QComboBox()
        self.form.addItems(
            [&#34;Thrust (propeller)&#34;, &#34;Torque (Turbine)&#34;, &#34;max dQ min dT&#34;])

        self.buttonAngles = QPushButton(&#34;Run angle optimization&#34;)
        self.buttonAngles.clicked.connect(self.run)

        self.target_rpm_propeller = QLineEdit()
        self.target_rpm_propeller.setValidator(self.validator)
        self.target_rpm_propeller.textChanged.connect(self.check_state)
        self.target_rpm.textChanged.emit(self.target_rpm_propeller.text())
        self._target_rpm_propeller = QLabel(&#39;Target rpm (prop.) [RPM]&#39;)
        self.form_list.append(
            [self._target_rpm_propeller, self.target_rpm_propeller])

        self.buttonBoth = QPushButton(&#39;Run optimization for turbine/propeller&#39;)
        self.buttonBoth.clicked.connect(self.run_both)

        self.buttonOptimalPitch = QPushButton(&#34;Find optimal pitch&#34;)
        self.buttonOptimalPitch.clicked.connect(self.run_optimal_pitch)

        self.buttonStop = QPushButton(&#34;Stop&#34;)
        self.buttonStop.clicked.connect(self.terminate)

        self.buttonClear = QPushButton(&#34;Clear screen&#34;)
        self.buttonClear.clicked.connect(self.clear)

        self.buttonEOF = QCheckBox()
        self.buttonEOF.setChecked(True)
        self.buttonEOFdescription = QLabel(&#34;Scroll to end of screen&#34;)

        self.grid = QGridLayout()
        self.setLayout(self.grid)
        self.grid.addWidget(self.left, 1, 1)
        self.grid.addWidget(self.textEdit, 1, 2)

        self.fbox = QFormLayout()
        self.left.setLayout(self.fbox)
        self.fbox.addRow(self._target_speed, self.target_speed)
        self.fbox.addRow(self._target_rpm, self.target_rpm)
        self.fbox.addRow(self._form, self.form)

        # self.fbox.addRow(QLabel(&#34;--------&#34;))
        self.fbox.addRow(self.buttonAngles)
        self.fbox.addRow(self.buttonOptimalPitch)
        self.fbox.addRow(&#34;&#34;, QLabel())
        self.fbox.addRow(self._target_rpm_propeller, self.target_rpm_propeller)
        self.fbox.addRow(self.buttonBoth)

        self.fbox.addRow(self.buttonClear, self.buttonStop)
        self.fbox.addRow(self.buttonEOFdescription, self.buttonEOF)

    def check_forms_angles(self):
        out = &#34;&#34;
        _needed_vars = [[self._target_speed, self.target_speed], [
            self._target_rpm, self.target_rpm], ]
        for n, f in _needed_vars:
            if isinstance(f, QLineEdit):
                state = self.validator.validate(f.text(), 0)[0]
                if state == QtGui.QValidator.Acceptable:
                    pass
                elif state == QtGui.QValidator.Intermediate:
                    out += &#34;Form %s appears not to be valid.\n&#34; % n.text()
                else:
                    out += &#34;Form %s is not of the valid type.\n&#34; % n.text()
        if out == &#34;&#34;:
            return True
        return out

    def check_state(self, *args, **kwargs):
        sender = self.sender()
        validator = sender.validator()
        state = validator.validate(sender.text(), 0)[0]
        if state == QtGui.QValidator.Acceptable:
            color = &#34;#edf5e1&#34;  # green
        elif state == QtGui.QValidator.Intermediate:
            color = &#34;#fff79a&#34;  # yellow
        else:
            color = &#34;#f6989d&#34;  # red
        sender.setStyleSheet(&#34;QLineEdit { background-color: %s }&#34; % color)

    def run(self):
        self.clear()
        check = self.check_forms_angles()
        check_analysis = self.main.analysis.check_forms()
        if check != True or check_analysis != True:
            if check == True:
                check = &#34;&#34;
            if check_analysis == True:
                check_analysis = &#34;&#34;
            check = check + check_analysis
            msg = QMessageBox()
            msg.setIcon(QMessageBox.Warning)
            msg.setText(&#34;Input validation error&#34;)
            msg.setDetailedText(check)
            msg.exec_()
            return

        self.main.emitter_add.connect(self.add_text)
        self.main.emitter_done.connect(self.done)

        if not self.main.running:
            self.main.set_buttons_running()
            self.main.running = True
            self.runner_input = self.main.get_input_params()
            if self.runner_input[&#34;optimization_variable&#34;] == &#34;dT&#34;:
                self.runner_input[&#34;propeller_mode&#34;] = True
            else:
                self.runner_input[&#34;propeller_mode&#34;] = False
            self.main.getter.start()
            self.p = Process(target=optimize_angles_genetic,
                             args=[self.runner_input])
            self.p.start()
        else:
            msg = QMessageBox()
            msg.setIcon(QMessageBox.Warning)
            msg.setText(&#34;Cannot run while existing operation is running&#34;)
            msg.setInformativeText(
                &#34;The program detected that an existing operation is running.&#34;)
            msg.setWindowTitle(&#34;Runtime error&#34;)
            msg.setDetailedText(&#34;Currently tha value MainWindow.running is %s, \
                it should be False.&#34; % str(self.main.running))

    def run_both(self):
        self.clear()
        check = self.check_forms_angles()
        check_analysis = self.main.analysis.check_forms()
        if check != True or check_analysis != True:
            if check == True:
                check = &#34;&#34;
            if check_analysis == True:
                check_analysis = &#34;&#34;
            check = check + check_analysis
            msg = QMessageBox()
            msg.setIcon(QMessageBox.Warning)
            msg.setText(&#34;Input validation error&#34;)
            msg.setDetailedText(check)
            msg.exec_()
            return

        self.main.emitter_add.connect(self.add_text)
        self.main.emitter_done.connect(self.done)

        if not self.main.running:
            self.main.set_buttons_running()
            self.main.running = True
            self.runner_input = self.main.get_input_params()
            self.main.getter.start()
            self.p = Process(target=maximize_for_both,
                             args=[self.runner_input])
            self.p.start()
        else:
            msg = QMessageBox()
            msg.setIcon(QMessageBox.Warning)
            msg.setText(&#34;Cannot run while existing operation is running&#34;)
            msg.setInformativeText(
                &#34;The program detected that an existing operation is running.&#34;)
            msg.setWindowTitle(&#34;Runtime error&#34;)
            msg.setDetailedText(&#34;Currently tha value MainWindow.running is %s, \
                it should be False.&#34; % str(self.main.running))

    def run_optimal_pitch(self):
        self.clear()
        check = self.check_forms_angles()
        check_analysis = self.main.analysis.check_forms()
        if check != True or check_analysis != True:
            if check == True:
                check = &#34;&#34;
            if check_analysis == True:
                check_analysis = &#34;&#34;
            check = check + check_analysis
            msg = QMessageBox()
            msg.setIcon(QMessageBox.Warning)
            msg.setText(&#34;Input validation error&#34;)
            msg.setDetailedText(check)
            msg.exec_()
            return

        self.main.emitter_add.connect(self.add_text)
        self.main.emitter_done.connect(self.done)

        if not self.main.running:
            self.main.set_buttons_running()
            self.main.running = True
            self.runner_input = self.main.get_input_params()
            self.main.getter.start()
            self.p = Process(target=optimal_pitch, args=[self.runner_input])
            self.p.start()
        else:
            msg = QMessageBox()
            msg.setIcon(QMessageBox.Warning)
            msg.setText(&#34;Cannot run while existing operation is running&#34;)
            msg.setInformativeText(
                &#34;The program detected that an existing operation is running.&#34;)
            msg.setWindowTitle(&#34;Runtime error&#34;)
            msg.setDetailedText(&#34;Currently tha value MainWindow.running is %s, \
                it should be False.&#34; % str(self.main.running))

    def clear(self):
        self.textEdit.clear()

    def add_text(self, string):
        self.textEdit.insertPlainText(string)
        if self.buttonEOF.checkState() == 2:
            self.textEdit.moveCursor(QtGui.QTextCursor.End)

    def run_pitch(self):
        self.run(True)

    def terminate(self):
        if hasattr(self, &#34;p&#34;):
            if self.p.is_alive():
                self.p.terminate()
                self.main.running = False
                self.main.getter.__del__()
                self.done(True)

    def done(self, terminated=False):
        self.main.emitter_add.disconnect()
        self.main.emitter_done.disconnect()
        self.main.set_buttons_await()
        self.main.running = False
        self.main.getter.__del__()
        if not terminated:
            self.p.join()

    def get_settings(self):
        out = {}
        out[&#34;target_rpm&#34;] = self.target_rpm.text()
        out[&#34;target_speed&#34;] = self.target_speed.text()
        out[&#39;target_rpm_propeller&#39;] = self.target_rpm_propeller.text()
        if int(self.form.currentIndex()) == 0:
            out[&#34;optimization_variable&#34;] = &#34;dT&#34;
        elif int(self.form.currentIndex()) == 1:
            out[&#34;optimization_variable&#34;] = &#34;dQ&#34;
        elif int(self.form.currentIndex()) == 2:
            out[&#34;optimization_variable&#34;] = &#34;max dT min dQ&#34;
        for k, v in out.items():
            if v == &#34;&#34;:
                v = None
            elif v == None:
                pass
            else:
                if not k == &#34;optimization_variable&#34;:
                    v = to_float(v)
            out[k] = v
        return out

    def set_settings(self, inp_dict):
        self.target_rpm.setText(str(inp_dict[&#34;target_rpm&#34;]))
        self.target_speed.setText(str(inp_dict[&#34;target_speed&#34;]))
        self.target_rpm_propeller.setText(
            str(inp_dict[&#39;target_rpm_propeller&#39;]))


class ThreadGetter(QThread):
    def __init__(self, parent):
        super(ThreadGetter, self).__init__(parent)

    def __del__(self):
        self.wait()

    def run(self):
        print(&#34;Running Getter.&#34;)
        while True:
            if len(self.parent().return_print) &gt; 0:
                t = self.parent().return_print.pop(0)
                self.parent().emitter_add.emit(str(t))
                if &#34;!!!!EOF!!!!&#34; in t:
                    self.parent().emitter_done.emit()
                    break
            if self.parent().running == False:
                break
        print(&#34;Getter finished.&#34;)
        return


class TabWidget(QtWidgets.QTabWidget):
    def __init__(self, parent=None):
        super(TabWidget, self).__init__(parent)
        self.tabs = []

    def add_tab(self, widget, tab_name):
        for t, n in self.tabs:
            if n == tab_name:
                print(&#34;n&#34;, n, &#34;tab_name&#34;, tab_name)
                msg = QMessageBox()
                msg.setIcon(QMessageBox.Warning)
                msg.setText(&#34;Tab with same name already exists!&#34;)
                msg.exec_()
                return
        self.tabs.append([widget, tab_name])
        self.addTab(widget, tab_name)
        return

    def remove_tab(self, index):
        self.removeTab(index)
        del self.tabs[index]

    def remove_all_tabs(self):
        while len(self.tabs) &gt; 0:
            self.remove_tab(0)

    def remove_current_tab(self):
        self.remove_tab(self.currentIndex())

    def rename_current_tab(self, string):
        self.setTabText(self.currentIndex(), string)
        self.tabs[self.currentIndex()][1] = string

    def current_tab_name(self):
        return self.tabText(self.currentIndex())


if __name__ == &#34;__main__&#34;:
    if sys.platform.startswith(&#34;win&#34;):
        # On Windows calling this function is necessary for multiprocessing.
        multiprocessing.freeze_support()
        # To show icon in taskbar
        myappid = &#39;FEUM.BEM_Analiza.v0.3.0&#39;  # arbitrary string
        ctypes.windll.shell32.SetCurrentProcessExplicitAppUserModelID(myappid)

    app = QtWidgets.QApplication([])
    app_icon = QtGui.QIcon(&#34;icon_bem.ico&#34;)
    app.setWindowIcon(app_icon)
    app.setStyle(&#34;Fusion&#34;)
    if sys.platform.startswith(&#34;darwin&#34;):
        # dark theme fix on OSX
        palette = QDarkPalette()
        palette.set_app(app)
        palette.set_stylesheet(app)
    screen = app.primaryScreen()
    size = screen.size()
    main = MainWindow(size.width(), size.height())
    sys.exit(app.exec_())</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="bem_src.main.AirfoilManager"><code class="flex name class">
<span>class <span class="ident">AirfoilManager</span></span>
<span>(</span><span>parent=None)</span>
</code></dt>
<dd>
<section class="desc"><p>QWidget(parent: QWidget = None, flags: Union[Qt.WindowFlags, Qt.WindowType] = Qt.WindowFlags())</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AirfoilManager(QWidget):
    # popup_close = pyqtSignal(str)
    emitter = pyqtSignal(str)

    def __init__(self, parent=None):
        super(AirfoilManager, self).__init__(parent)

        self.main = self.parent()

        self.grid = QGridLayout()
        self.setLayout(self.grid)

        self.tab_widget = TabWidget(self)
        self.grid.addWidget(self.tab_widget, 2, 0)

        self.upper_widget = QWidget()
        self.upper_layout = QGridLayout()
        self.upper_widget.setLayout(self.upper_layout)
        self.grid.addWidget(self.upper_widget, 1, 0)

        self.button_add_foil = QPushButton(&#34;Add airfoil&#34;)
        self.button_add_foil.clicked.connect(self.add_foil_popup)
        self.button_remove_foil = QPushButton(&#34;Remove foil&#34;)
        self.button_remove_foil.clicked.connect(
            self.tab_widget.remove_current_tab)
        self.button_rename_foil = QPushButton(&#34;Rename foil&#34;)
        self.button_rename_foil.clicked.connect(self.rename_foil_popup)
        self.button_get_settings = QPushButton(&#34;get settings&#34;)
        self.button_get_settings.clicked.connect(self.get_settings)

        self.upper_layout.addWidget(self.button_add_foil, 0, 1)
        self.upper_layout.addWidget(self.button_remove_foil, 0, 2)
        self.upper_layout.addWidget(self.button_rename_foil, 0, 3)
        self.upper_layout.addWidget(self.button_get_settings, 0, 4)

    def add_foil_popup(self):
        self.emitter.connect(self.add_foil)
        self.p = PopupText(self, &#34;foil name&#34;, &#34;airfoil_name&#34;,
                           self.emitter, &#34;Add foil&#34;)
        self.p.setGeometry(QRect(100, 100, 400, 200))
        self.p.show()

    def add_foil(self, string):
        c = Airfoils(string, self)
        self.tab_widget.add_tab(c, string)

    def rename_foil_popup(self):
        self.emitter.connect(self.rename_foil)
        self.p = PopupText(self, &#34;foil name&#34;, self.tab_widget.current_tab_name(
        ), self.emitter, &#34;Rename foil&#34;)
        self.p.setGeometry(QRect(100, 100, 400, 200))
        self.p.show()

    def rename_foil(self, string):
        self.tab_widget.rename_current_tab(string)  # self.tab_widget.tabs

    def get_settings(self):
        out = {}
        i = 0

        # TODO Dont rely on name being set correctly in n!
        for w, n in self.tab_widget.tabs:
            out[n] = w.get_settings()
            i += 1

        return {&#34;airfoils&#34;: out}

    def set_settings(self, dict_settings):
        self.tab_widget.remove_all_tabs()
        if &#34;airfoils&#34; in dict_settings:
            if len(dict_settings[&#34;airfoils&#34;]) &gt; 0:
                for c_name, c_dict in dict_settings[&#34;airfoils&#34;].items():
                    curve_widget = Airfoils(c_name, self)
                    try:
                        curve_widget.set_settings(c_dict)
                        self.tab_widget.add_tab(curve_widget, c_name)
                    except:
                        pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="bem_src.main.AirfoilManager.add_foil"><code class="name flex">
<span>def <span class="ident">add_foil</span></span>(<span>self, string)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_foil(self, string):
    c = Airfoils(string, self)
    self.tab_widget.add_tab(c, string)</code></pre>
</details>
</dd>
<dt id="bem_src.main.AirfoilManager.add_foil_popup"><code class="name flex">
<span>def <span class="ident">add_foil_popup</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_foil_popup(self):
    self.emitter.connect(self.add_foil)
    self.p = PopupText(self, &#34;foil name&#34;, &#34;airfoil_name&#34;,
                       self.emitter, &#34;Add foil&#34;)
    self.p.setGeometry(QRect(100, 100, 400, 200))
    self.p.show()</code></pre>
</details>
</dd>
<dt id="bem_src.main.AirfoilManager.emitter"><code class="name flex">
<span>def <span class="ident">emitter</span></span>(<span>...)</span>
</code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="bem_src.main.AirfoilManager.get_settings"><code class="name flex">
<span>def <span class="ident">get_settings</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_settings(self):
    out = {}
    i = 0

    # TODO Dont rely on name being set correctly in n!
    for w, n in self.tab_widget.tabs:
        out[n] = w.get_settings()
        i += 1

    return {&#34;airfoils&#34;: out}</code></pre>
</details>
</dd>
<dt id="bem_src.main.AirfoilManager.rename_foil"><code class="name flex">
<span>def <span class="ident">rename_foil</span></span>(<span>self, string)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rename_foil(self, string):
    self.tab_widget.rename_current_tab(string)  # self.tab_widget.tabs</code></pre>
</details>
</dd>
<dt id="bem_src.main.AirfoilManager.rename_foil_popup"><code class="name flex">
<span>def <span class="ident">rename_foil_popup</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rename_foil_popup(self):
    self.emitter.connect(self.rename_foil)
    self.p = PopupText(self, &#34;foil name&#34;, self.tab_widget.current_tab_name(
    ), self.emitter, &#34;Rename foil&#34;)
    self.p.setGeometry(QRect(100, 100, 400, 200))
    self.p.show()</code></pre>
</details>
</dd>
<dt id="bem_src.main.AirfoilManager.set_settings"><code class="name flex">
<span>def <span class="ident">set_settings</span></span>(<span>self, dict_settings)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_settings(self, dict_settings):
    self.tab_widget.remove_all_tabs()
    if &#34;airfoils&#34; in dict_settings:
        if len(dict_settings[&#34;airfoils&#34;]) &gt; 0:
            for c_name, c_dict in dict_settings[&#34;airfoils&#34;].items():
                curve_widget = Airfoils(c_name, self)
                try:
                    curve_widget.set_settings(c_dict)
                    self.tab_widget.add_tab(curve_widget, c_name)
                except:
                    pass</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="bem_src.main.Airfoils"><code class="flex name class">
<span>class <span class="ident">Airfoils</span></span>
<span>(</span><span>airfoil_name, parent=None)</span>
</code></dt>
<dd>
<section class="desc"><p>QWidget(parent: QWidget = None, flags: Union[Qt.WindowFlags, Qt.WindowType] = Qt.WindowFlags())</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Airfoils(QWidget):
    def __init__(self, airfoil_name, parent=None):
        super(Airfoils, self).__init__(parent)

        self.curves = Curves()

        self.viewer = CurveViewer(self)

        self.airfoil_name = airfoil_name

        grid = QGridLayout()
        self.setLayout(grid)

        self.interp_function_cl = None
        self.interp_function_cd = None

        self.table_dat = Table()
        self.table_dat.createEmpty(2, 50)
        self.table_dat.set_labels([&#34;x&#34;, &#34;y&#34;])
        grid.addWidget(self.table_dat, 1, 1)

        self.plt = plt.figure(figsize=(10, 5))
        self.canvas = FigureCanvas(self.plt)
        toolbar = NavigationToolbar(self.canvas, self)
        grid.addWidget(self.canvas, 1, 2)

        self.ax = self.plt.add_subplot(111)
        grid.addWidget(toolbar, 2, 2)

        self.buttonRefresh = QPushButton(&#34;Refresh curve&#34;)
        grid.addWidget(self.buttonRefresh, 2, 1)

        self.buttonRefresh.clicked.connect(self.draw_airfoil)
        self.link = QLineEdit(&#34;link (airfoiltools.com)&#34;)
        grid.addWidget(self.link, 3, 1)

        #self.button_generate_interp = QPushButton(&#34;Generate interp functions&#34;)
        # self.button_generate_interp.clicked.connect(self.generate_interp_functions)
        #grid.addWidget(self.button_generate_interp, 3, 2)

        self.button_open_viewer = QPushButton(&#34;Open Curve Viewer&#34;)
        self.button_open_viewer.clicked.connect(self.open_viewer)
        grid.addWidget(self.button_open_viewer, 4, 2)

        self.button_generate_curves_xfoil = QPushButton(
            &#34;Generate xfoil curves [debug]&#34;)
        self.button_generate_curves_xfoil.clicked.connect(
            self.generate_curves_xfoil)
        grid.addWidget(self.button_generate_curves_xfoil, 4, 1)

        self.button_generate_curves_link = QPushButton(
            &#34;Generate curves from link&#34;)
        self.button_generate_curves_link.clicked.connect(
            self.generate_curves_link)
        grid.addWidget(self.button_generate_curves_link, 5, 1)

        self.button_visualize = QPushButton(&#34;Create curve visualization&#34;)
        self.button_visualize.clicked.connect(self.visualize)
        grid.addWidget(self.button_visualize, 5, 2)

        self.get_centroid_button = QPushButton(&#34;Calculate centroid&#34;)
        self.get_centroid_button.clicked.connect(self.calculate_centroid)
        grid.addWidget(self.get_centroid_button, 6, 1)

        self.centroid_widget = QWidget()
        self.centroid_grid = QGridLayout()
        self.centroid_widget.setLayout(self.centroid_grid)
        grid.addWidget(self.centroid_widget, 6, 2)

        self.centroid_x_edit = QLineEdit()
        self.centroid_y_edit = QLineEdit()

        self.centroid_grid.addWidget(self.centroid_x_edit, 1, 1)
        self.centroid_grid.addWidget(self.centroid_y_edit, 1, 2)

    def visualize(self):
        print(&#34;Visualizing&#34;)
        data = self.curves.gather_curves()

        re = data[:, 0]
        alpha = data[:, 2]
        cl = data[:, 3]
        cd = data[:, 4]

        re_min, re_max = data[:, 0].min(), data[:, 0].max()
        alpha_min, alpha_max = data[:, 2].min(), data[:, 2].max()

        x, y = np.linspace(re_min, re_max, 10), np.linspace(
            alpha_min, alpha_max, 180)
        xi, yi = np.meshgrid(x, y)
        xi, yi = xi.flatten(), yi.flatten()
        z_1 = interp_at(re, alpha, cl, xi, yi)
        z_2 = interp_at(re, alpha, cd, xi, yi)
        w = MatplotlibWindow(self)
        w.ax = w.figure.add_subplot(111, projection=&#34;3d&#34;)
        #w.ax.scatter(xi, yi, z_1)
        #w.ax.scatter(xi, yi, z_2)
        p = w.ax.plot_trisurf(xi, yi, z_1, cmap=cm.coolwarm)
        w.ax.set_xlabel(&#34;Reynolds&#34;, fontsize=15, labelpad=20)
        w.ax.set_ylabel(r&#39;$\alpha$ [°]&#39;, fontsize=15, labelpad=20)
        w.ax.set_zlabel(&#34;Cl&#34;, fontsize=15, labelpad=20)
        w.ax.xaxis.set_tick_params(labelsize=12)
        w.ax.yaxis.set_tick_params(labelsize=12)
        w.ax.zaxis.set_tick_params(labelsize=12)
        bar = w.figure.colorbar(p)
        bar.ax.set_xlabel(&#39;Cl&#39;, fontsize=15, labelpad=20)

        w2 = MatplotlibWindow(self)
        w2.ax = w2.figure.add_subplot(111, projection=&#34;3d&#34;)
        #w.ax.scatter(xi, yi, z_1)
        #w.ax.scatter(xi, yi, z_2)
        p = w2.ax.plot_trisurf(xi, yi, z_2, cmap=cm.coolwarm)
        w2.ax.set_xlabel(&#34;Reynolds&#34;, fontsize=15, labelpad=20)
        w2.ax.set_ylabel(r&#39;$\alpha$ [°]&#39;, fontsize=15, labelpad=20)
        w2.ax.set_zlabel(&#34;Cd&#34;, fontsize=15, labelpad=20)
        w2.ax.xaxis.set_tick_params(labelsize=12)
        w2.ax.yaxis.set_tick_params(labelsize=12)
        w2.ax.zaxis.set_tick_params(labelsize=12)
        bar2 = w2.figure.colorbar(p)
        bar2.ax.set_xlabel(&#39;Cd&#39;, fontsize=15, labelpad=20)

    def open_viewer(self):
        print(&#34;opening viewwer&#34;)
        self.viewer.show()
        self.viewer.generate_views()

    def generate_interp_functions(self):
        data = self.gather_curves()
        x, y = self.get_x_y()
        self.interp_function_cl, self.interp_function_cd = get_cl_cd_interpolation_function(
            data, x, y)

    def generate_curves_xfoil(self):
        print(&#34;Generating xfoil curves&#34;)
        data = generate_polars_data(self.airfoil_name + &#34;.dat&#34;)
        self.populate_curve_list(data)
        print(&#34;Done&#34;)

    def generate_curves_link(self):
        print(&#34;Scraping from link...&#34;)
        data = scrape_data(self.link.text())
        self.populate_curve_list(data)
        print(&#34;Done&#34;)

    def populate_curve_list(self, data):
        self.curves.curve_list = []
        x, y = self.get_x_y()
        Re_list = np.unique(data[:, 0])
        ncrit_list = np.unique(data[:, 1])
        ncrit_selected = np.min(ncrit_list)
        for Re in Re_list:
            rows_with_Re = data[np.in1d(data[:, 0], Re)]
            rows_with_Re = rows_with_Re[np.in1d(
                rows_with_Re[:, 1], ncrit_selected)]
            _alpha = rows_with_Re[:, 2].flatten()
            _cl = rows_with_Re[:, 3].flatten()
            _cd = rows_with_Re[:, 4].flatten()
            c = Curve()
            c.create(x=x, y=y, Re=Re, ncrit=ncrit_selected,
                     alpha=_alpha, cl=_cl, cd=_cd)
            self.curves.add(c)

    def draw_airfoil(self):
        self.ax.clear()
        x_values = []
        y_values = []
        array_dat = self.table_dat.get_values()
        for r in array_dat:
            if r[0] != &#34;&#34; and r[1] != &#34;&#34;:
                # noinspection PyBroadException
                try:
                    _x = to_float(r[0])
                    _y = to_float(r[1])
                except:
                    print(&#34;Error drawing airfoil because _x or _y isn&#39;t a float.&#34;)
                    return
                x_values.append(_x)
                y_values.append(_y)
        self.ax.set_xlim(0, 1)
        self.ax.set_ylim(-0.5, 0.5)
        self.ax.plot(x_values, y_values)
        try:
            centroid_x = float(self.centroid_x_edit.text())
            centroid_y = float(self.centroid_y_edit.text())
            self.ax.plot(centroid_x, centroid_y, &#34;r+&#34;)
        except Exception as e:
            msg = QMessageBox()
            msg.setIcon(QMessageBox.Warning)
            msg.setText(&#34;Error while getting settings&#34;)
            msg.setDetailedText(str(e))
            msg.exec_()
            print(e)

        self.plt.canvas.draw()

    def get_max_thickness(self):
        x = []
        y = []
        array_dat = self.table_dat.get_values()
        for r in array_dat:
            if r[0] != &#34;&#34; and r[1] != &#34;&#34;:
                _x = to_float(r[0])
                _y = to_float(r[1])
                x.append(_x)
                y.append(_y)
        if len(y) &gt; 0:
            y_max = numpy.max(y)
            y_min = numpy.min(y)
            thickness = (abs(y_max) + abs(y_min)) / 1
            return thickness
        return None

    def get_x_y(self):
        x = []
        y = []

        array_dat = self.table_dat.get_values()
        for r in array_dat:
            if r[0] != &#34;&#34; and r[1] != &#34;&#34;:
                _x = to_float(r[0])
                _y = to_float(r[1])
                x.append(_x)
                y.append(_y)
        return x, y

    def calculate_centroid(self):
        foil_x, foil_y = self.get_x_y()
        x, y = get_centroid_coordinates(foil_x, foil_y)
        self.centroid_x_edit.setText(str(x))
        self.centroid_y_edit.setText(str(y))
        return x, y

    def get_settings(self):
        x, y = self.get_x_y()
        try:
            centroid_x = float(self.centroid_x_edit.text())
            centroid_y = float(self.centroid_y_edit.text())
            out = {&#34;x&#34;: x, &#34;y&#34;: y, &#34;max_thickness&#34;: self.get_max_thickness(), &#34;link&#34;: self.link.text(),
                   &#34;interp_function_cl&#34;: self.interp_function_cl, &#34;interp_function_cd&#34;: self.interp_function_cd,
                   &#34;curves&#34;: self.curves.save_curves(), &#34;gathered_curves&#34;: self.curves.gather_curves(),
                   &#34;centroid_x&#34;: centroid_x, &#34;centroid_y&#34;: centroid_y}
            return out
        except Exception as e:
            raise Exception(&#34;Error in airfoil %s... (%s)&#34; %
                            (self.airfoil_name, str(e)))

    def set_settings(self, dict_settings):
        array_dat = []
        if len(dict_settings[&#34;x&#34;]) &gt; 0 and len(dict_settings[&#34;y&#34;]) &gt; 0:
            for r in range(len(dict_settings[&#34;x&#34;])):
                array_dat.append([str(dict_settings[&#34;x&#34;][r]),
                                  str(dict_settings[&#34;y&#34;][r])])
            self.table_dat.createTable(array_dat)
            self.calculate_centroid()
            self.draw_airfoil()

        self.link.setText(dict_settings[&#34;link&#34;])
        self.curves.load_curves(dict_settings[&#34;curves&#34;])</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="bem_src.main.Airfoils.calculate_centroid"><code class="name flex">
<span>def <span class="ident">calculate_centroid</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_centroid(self):
    foil_x, foil_y = self.get_x_y()
    x, y = get_centroid_coordinates(foil_x, foil_y)
    self.centroid_x_edit.setText(str(x))
    self.centroid_y_edit.setText(str(y))
    return x, y</code></pre>
</details>
</dd>
<dt id="bem_src.main.Airfoils.draw_airfoil"><code class="name flex">
<span>def <span class="ident">draw_airfoil</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_airfoil(self):
    self.ax.clear()
    x_values = []
    y_values = []
    array_dat = self.table_dat.get_values()
    for r in array_dat:
        if r[0] != &#34;&#34; and r[1] != &#34;&#34;:
            # noinspection PyBroadException
            try:
                _x = to_float(r[0])
                _y = to_float(r[1])
            except:
                print(&#34;Error drawing airfoil because _x or _y isn&#39;t a float.&#34;)
                return
            x_values.append(_x)
            y_values.append(_y)
    self.ax.set_xlim(0, 1)
    self.ax.set_ylim(-0.5, 0.5)
    self.ax.plot(x_values, y_values)
    try:
        centroid_x = float(self.centroid_x_edit.text())
        centroid_y = float(self.centroid_y_edit.text())
        self.ax.plot(centroid_x, centroid_y, &#34;r+&#34;)
    except Exception as e:
        msg = QMessageBox()
        msg.setIcon(QMessageBox.Warning)
        msg.setText(&#34;Error while getting settings&#34;)
        msg.setDetailedText(str(e))
        msg.exec_()
        print(e)

    self.plt.canvas.draw()</code></pre>
</details>
</dd>
<dt id="bem_src.main.Airfoils.generate_curves_link"><code class="name flex">
<span>def <span class="ident">generate_curves_link</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_curves_link(self):
    print(&#34;Scraping from link...&#34;)
    data = scrape_data(self.link.text())
    self.populate_curve_list(data)
    print(&#34;Done&#34;)</code></pre>
</details>
</dd>
<dt id="bem_src.main.Airfoils.generate_curves_xfoil"><code class="name flex">
<span>def <span class="ident">generate_curves_xfoil</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_curves_xfoil(self):
    print(&#34;Generating xfoil curves&#34;)
    data = generate_polars_data(self.airfoil_name + &#34;.dat&#34;)
    self.populate_curve_list(data)
    print(&#34;Done&#34;)</code></pre>
</details>
</dd>
<dt id="bem_src.main.Airfoils.generate_interp_functions"><code class="name flex">
<span>def <span class="ident">generate_interp_functions</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_interp_functions(self):
    data = self.gather_curves()
    x, y = self.get_x_y()
    self.interp_function_cl, self.interp_function_cd = get_cl_cd_interpolation_function(
        data, x, y)</code></pre>
</details>
</dd>
<dt id="bem_src.main.Airfoils.get_max_thickness"><code class="name flex">
<span>def <span class="ident">get_max_thickness</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_max_thickness(self):
    x = []
    y = []
    array_dat = self.table_dat.get_values()
    for r in array_dat:
        if r[0] != &#34;&#34; and r[1] != &#34;&#34;:
            _x = to_float(r[0])
            _y = to_float(r[1])
            x.append(_x)
            y.append(_y)
    if len(y) &gt; 0:
        y_max = numpy.max(y)
        y_min = numpy.min(y)
        thickness = (abs(y_max) + abs(y_min)) / 1
        return thickness
    return None</code></pre>
</details>
</dd>
<dt id="bem_src.main.Airfoils.get_settings"><code class="name flex">
<span>def <span class="ident">get_settings</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_settings(self):
    x, y = self.get_x_y()
    try:
        centroid_x = float(self.centroid_x_edit.text())
        centroid_y = float(self.centroid_y_edit.text())
        out = {&#34;x&#34;: x, &#34;y&#34;: y, &#34;max_thickness&#34;: self.get_max_thickness(), &#34;link&#34;: self.link.text(),
               &#34;interp_function_cl&#34;: self.interp_function_cl, &#34;interp_function_cd&#34;: self.interp_function_cd,
               &#34;curves&#34;: self.curves.save_curves(), &#34;gathered_curves&#34;: self.curves.gather_curves(),
               &#34;centroid_x&#34;: centroid_x, &#34;centroid_y&#34;: centroid_y}
        return out
    except Exception as e:
        raise Exception(&#34;Error in airfoil %s... (%s)&#34; %
                        (self.airfoil_name, str(e)))</code></pre>
</details>
</dd>
<dt id="bem_src.main.Airfoils.get_x_y"><code class="name flex">
<span>def <span class="ident">get_x_y</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_x_y(self):
    x = []
    y = []

    array_dat = self.table_dat.get_values()
    for r in array_dat:
        if r[0] != &#34;&#34; and r[1] != &#34;&#34;:
            _x = to_float(r[0])
            _y = to_float(r[1])
            x.append(_x)
            y.append(_y)
    return x, y</code></pre>
</details>
</dd>
<dt id="bem_src.main.Airfoils.open_viewer"><code class="name flex">
<span>def <span class="ident">open_viewer</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open_viewer(self):
    print(&#34;opening viewwer&#34;)
    self.viewer.show()
    self.viewer.generate_views()</code></pre>
</details>
</dd>
<dt id="bem_src.main.Airfoils.populate_curve_list"><code class="name flex">
<span>def <span class="ident">populate_curve_list</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def populate_curve_list(self, data):
    self.curves.curve_list = []
    x, y = self.get_x_y()
    Re_list = np.unique(data[:, 0])
    ncrit_list = np.unique(data[:, 1])
    ncrit_selected = np.min(ncrit_list)
    for Re in Re_list:
        rows_with_Re = data[np.in1d(data[:, 0], Re)]
        rows_with_Re = rows_with_Re[np.in1d(
            rows_with_Re[:, 1], ncrit_selected)]
        _alpha = rows_with_Re[:, 2].flatten()
        _cl = rows_with_Re[:, 3].flatten()
        _cd = rows_with_Re[:, 4].flatten()
        c = Curve()
        c.create(x=x, y=y, Re=Re, ncrit=ncrit_selected,
                 alpha=_alpha, cl=_cl, cd=_cd)
        self.curves.add(c)</code></pre>
</details>
</dd>
<dt id="bem_src.main.Airfoils.set_settings"><code class="name flex">
<span>def <span class="ident">set_settings</span></span>(<span>self, dict_settings)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_settings(self, dict_settings):
    array_dat = []
    if len(dict_settings[&#34;x&#34;]) &gt; 0 and len(dict_settings[&#34;y&#34;]) &gt; 0:
        for r in range(len(dict_settings[&#34;x&#34;])):
            array_dat.append([str(dict_settings[&#34;x&#34;][r]),
                              str(dict_settings[&#34;y&#34;][r])])
        self.table_dat.createTable(array_dat)
        self.calculate_centroid()
        self.draw_airfoil()

    self.link.setText(dict_settings[&#34;link&#34;])
    self.curves.load_curves(dict_settings[&#34;curves&#34;])</code></pre>
</details>
</dd>
<dt id="bem_src.main.Airfoils.visualize"><code class="name flex">
<span>def <span class="ident">visualize</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visualize(self):
    print(&#34;Visualizing&#34;)
    data = self.curves.gather_curves()

    re = data[:, 0]
    alpha = data[:, 2]
    cl = data[:, 3]
    cd = data[:, 4]

    re_min, re_max = data[:, 0].min(), data[:, 0].max()
    alpha_min, alpha_max = data[:, 2].min(), data[:, 2].max()

    x, y = np.linspace(re_min, re_max, 10), np.linspace(
        alpha_min, alpha_max, 180)
    xi, yi = np.meshgrid(x, y)
    xi, yi = xi.flatten(), yi.flatten()
    z_1 = interp_at(re, alpha, cl, xi, yi)
    z_2 = interp_at(re, alpha, cd, xi, yi)
    w = MatplotlibWindow(self)
    w.ax = w.figure.add_subplot(111, projection=&#34;3d&#34;)
    #w.ax.scatter(xi, yi, z_1)
    #w.ax.scatter(xi, yi, z_2)
    p = w.ax.plot_trisurf(xi, yi, z_1, cmap=cm.coolwarm)
    w.ax.set_xlabel(&#34;Reynolds&#34;, fontsize=15, labelpad=20)
    w.ax.set_ylabel(r&#39;$\alpha$ [°]&#39;, fontsize=15, labelpad=20)
    w.ax.set_zlabel(&#34;Cl&#34;, fontsize=15, labelpad=20)
    w.ax.xaxis.set_tick_params(labelsize=12)
    w.ax.yaxis.set_tick_params(labelsize=12)
    w.ax.zaxis.set_tick_params(labelsize=12)
    bar = w.figure.colorbar(p)
    bar.ax.set_xlabel(&#39;Cl&#39;, fontsize=15, labelpad=20)

    w2 = MatplotlibWindow(self)
    w2.ax = w2.figure.add_subplot(111, projection=&#34;3d&#34;)
    #w.ax.scatter(xi, yi, z_1)
    #w.ax.scatter(xi, yi, z_2)
    p = w2.ax.plot_trisurf(xi, yi, z_2, cmap=cm.coolwarm)
    w2.ax.set_xlabel(&#34;Reynolds&#34;, fontsize=15, labelpad=20)
    w2.ax.set_ylabel(r&#39;$\alpha$ [°]&#39;, fontsize=15, labelpad=20)
    w2.ax.set_zlabel(&#34;Cd&#34;, fontsize=15, labelpad=20)
    w2.ax.xaxis.set_tick_params(labelsize=12)
    w2.ax.yaxis.set_tick_params(labelsize=12)
    w2.ax.zaxis.set_tick_params(labelsize=12)
    bar2 = w2.figure.colorbar(p)
    bar2.ax.set_xlabel(&#39;Cd&#39;, fontsize=15, labelpad=20)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="bem_src.main.Analysis"><code class="flex name class">
<span>class <span class="ident">Analysis</span></span>
<span>(</span><span>parent=None)</span>
</code></dt>
<dd>
<section class="desc"><p>QWidget(parent: QWidget = None, flags: Union[Qt.WindowFlags, Qt.WindowType] = Qt.WindowFlags())</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Analysis(QWidget):
    def __init__(self, parent=None):
        super(Analysis, self).__init__(parent)

        self.main = self.parent()

        self.settings = {&#34;propeller_mode&#34;: False, &#34;tip_loss&#34;: False, &#34;hub_loss&#34;: False, &#34;new_tip_loss&#34;: False,
                         &#34;new_hub_loss&#34;: False, &#34;cascade_correction&#34;: False,
                         &#34;rotational_augmentation_correction&#34;: False, &#34;rotational_augmentation_correction_method&#34;: 1,
                         &#34;mach_number_correction&#34;: False, &#34;max_iterations&#34;: 100, &#34;convergence_limit&#34;: 0.001,
                         &#34;rho&#34;: 1.225, &#34;method&#34;: 10, &#34;linspace_interp&#34;: False, &#34;num_interp&#34;: 25, &#34;v_min&#34;: 3,
                         &#34;v_max&#34;: 20, &#34;v_num&#34;: 10, &#34;rpm_min&#34;: 100, &#34;rpm_max&#34;: 3000, &#34;rpm_num&#34;: 10, &#34;pitch&#34;: 0.0,
                         &#34;relaxation_factor&#34;: 0.3, &#34;print_all&#34;: False, &#34;print_out&#34;: False, &#34;reynolds&#34;: 50000,
                         &#34;fix_reynolds&#34;: False}

        self.settings_to_name = {&#34;propeller_mode&#34;: &#34;Propeller mode&#34;, &#34;print_out&#34;: &#34;Print final iteration data&#34;,
                                 &#34;tip_loss&#34;: &#34;Prandtl tip loss&#34;, &#34;hub_loss&#34;: &#34;Prandtl hub loss&#34;,
                                 &#34;new_tip_loss&#34;: &#34;New tip loss&#34;, &#34;new_hub_loss&#34;: &#34;New hub loss&#34;,
                                 &#34;cascade_correction&#34;: &#34;Cascade correction&#34;, &#34;max_iterations&#34;: &#34;Maximum iterations&#34;,
                                 &#34;convergence_limit&#34;: &#34;Convergence criteria&#34;, &#34;rho&#34;: &#34;Air density [kg/m^3]&#34;,
                                 &#34;method&#34;: &#34;Calculation method&#34;, &#34;v_min&#34;: &#34;Min calc. wind speed [m/s]&#34;,
                                 &#34;v_max&#34;: &#34;Max calc. wind speed [m/s]&#34;, &#34;v_num&#34;: &#34;Number of wind speed points&#34;,
                                 &#34;rpm_min&#34;: &#34;Min calc. RPM [RPM]&#34;, &#34;rpm_max&#34;: &#34;Max calc. RPM [RPM]&#34;,
                                 &#34;rpm_num&#34;: &#34;Number of RPM points&#34;, &#34;relaxation_factor&#34;: &#34;Relaxation factor&#34;,
                                 &#34;print_all&#34;: &#34;Print every iteration [debug]&#34;,
                                 &#34;num_interp&#34;: &#34;Number of sections (interp)&#34;,
                                 &#34;linspace_interp&#34;: &#34;Custom number of sections&#34;,
                                 &#34;rotational_augmentation_correction&#34;: &#34;Rot. augmentation cor.&#34;,
                                 &#34;rotational_augmentation_correction_method&#34;: &#34;Rot. augmentation cor. method&#34;,
                                 &#34;fix_reynolds&#34;: &#34;Fix Reynolds&#34;, &#34;reynolds&#34;: &#34;Reynolds&#34;,
                                 &#34;mach_number_correction&#34;: &#34;Mach number correction&#34;, &#34;pitch&#34;: &#34;Pitch&#34;}

        self.list_settings_for_updating_tsr = [
            &#34;v_min&#34;, &#34;v_max&#34;, &#34;v_num&#34;, &#34;rpm_min&#34;, &#34;rpm_max&#34;, &#34;rpm_num&#34;]

        self.methods_to_names = METHODS_STRINGS

        self.name_to_methods = {v: k for k, v in self.methods_to_names.items()}
        self.name_to_settings = {v: k for k,
                                 v in self.settings_to_name.items()}

        self.grid = QGridLayout()
        self.setLayout(self.grid)

        self.left = QWidget()
        self.fbox = QFormLayout()
        self.left.setLayout(self.fbox)

        self.scroll_area = QtWidgets.QScrollArea()
        self.scroll_widget = QtWidgets.QWidget()
        self.scroll_widget_layout = QtWidgets.QVBoxLayout()

        self.scroll_widget.setLayout(self.scroll_widget_layout)
        self.scroll_area.setWidget(self.left)
        self.scroll_area.setWidgetResizable(True)

        self.grid.addWidget(self.scroll_area, 1, 1)

        self.textEdit = QTextEdit()
        self.textEdit.setReadOnly(True)
        self.grid.addWidget(self.textEdit, 1, 2)

        self.buttonRun = QPushButton(&#34;Run&#34;)

        self.form_list = []
        self.validator = QtGui.QDoubleValidator()

        for key, value in self.settings.items():
            if key == &#34;method&#34;:
                form = QComboBox()
                form.addItems([self.methods_to_names[k]
                               for k, v in self.methods_to_names.items()])
                form.setCurrentIndex(7)
            elif key == &#34;rotational_augmentation_correction_method&#34;:
                form = QComboBox()
                form.addItems([&#34;1&#34;, &#34;2&#34;, &#34;3&#34;, &#34;4&#34;, &#34;5&#34;])
            elif isinstance(value, bool):
                form = QCheckBox()
                form.setTristate(value)
            else:
                form = QLineEdit()
                form.setValidator(self.validator)
                form.textChanged.connect(self.check_state)
                form.textChanged.emit(form.text())
                form.insert(str(value))
                if key in self.list_settings_for_updating_tsr:
                    form.textChanged.connect(self.update_tsr_and_j)
            key_orig = key
            key = self.settings_to_name[key]
            self.fbox.addRow(key, form)
            self.form_list.append([key, form, key_orig])

        self.tsr_string = QLabel(&#34;0&#34;)
        self.J_string = QLabel(&#34;0&#34;)
        self.emptyLabel = QLabel(&#34; &#34;)
        self.buttonRun.clicked.connect(self.run)
        self.buttonClear = QPushButton(&#34;Clear screen&#34;)
        self.buttonClear.clicked.connect(self.clear)
        self.buttonEOF = QCheckBox()
        self.buttonEOF.setChecked(True)
        self.buttonEOFdescription = QLabel(&#34;Scroll to end of screen&#34;)
        self.buttonStop = QPushButton(&#34;Stop&#34;)
        self.buttonStop.clicked.connect(self.terminate)

        self.fbox.addRow(self.emptyLabel, self.buttonRun)
        self.fbox.addRow(self.buttonClear, self.buttonStop)
        self.fbox.addRow(self.buttonEOFdescription, self.buttonEOF)
        self.fbox.addRow(&#34;TSR:&#34;, self.tsr_string)
        self.fbox.addRow(&#34;J:&#34;, self.J_string)

    def update_tsr_and_j(self):
        try:
            s = self.get_settings()
            R = float(self.main.wind_turbine_properties.R.text())
            tsr_min = 2*np.pi*float(s[&#34;rpm_min&#34;])*R/60/float(s[&#34;v_max&#34;])
            tsr_max = 2*np.pi*float(s[&#34;rpm_max&#34;])*R/60/float(s[&#34;v_min&#34;])
            self.tsr_string.setText(&#34;%.2f - %.2f&#34; % (tsr_min, tsr_max))
            J_min = float(s[&#34;v_min&#34;])/(float(s[&#34;rpm_max&#34;])/60*2*R)
            J_max = float(s[&#34;v_max&#34;])/(float(s[&#34;rpm_min&#34;])/60*2*R)
            self.J_string.setText(&#34;%.2f - %.2f&#34; % (J_min, J_max))
        except:
            print(&#34;couldnt update tsr min/max or J min/max&#34;)

    def check_forms(self):
        out = &#34;&#34;
        for n, f, n_short in self.form_list:
            if isinstance(f, QLineEdit):
                state = self.validator.validate(f.text(), 0)[0]
                if state == QtGui.QValidator.Acceptable:
                    pass
                elif state == QtGui.QValidator.Intermediate:
                    out += &#34;Form %s appears not to be valid.\n&#34; % n
                else:
                    out += &#34;Form %s is not of the valid type.\n&#34; % n
        if out == &#34;&#34;:
            return True
        return out

    def check_state(self, *args, **kwargs):
        sender = self.sender()
        validator = sender.validator()
        state = validator.validate(sender.text(), 0)[0]
        if state == QtGui.QValidator.Acceptable:
            color = &#34;#edf5e1&#34;  # green
        elif state == QtGui.QValidator.Intermediate:
            color = &#34;#fff79a&#34;  # yellow
        else:
            color = &#34;#f6989d&#34;  # red
        sender.setStyleSheet(&#34;QLineEdit { background-color: %s }&#34; % color)

    def get_settings(self):
        out_settings = {}
        for name, value, name_short in self.form_list:
            name = self.name_to_settings[name]
            if isinstance(value, QCheckBox):
                value = bool(value.checkState())
            if isinstance(value, QLineEdit):
                value = to_float(value.text())
            if isinstance(value, QComboBox):
                value = int(value.currentIndex())
            out_settings[name] = value
        return out_settings

    def set_settings(self, inp_dict):
        for name_long, item, name in self.form_list:
            if name in inp_dict:
                if isinstance(item, QComboBox):
                    _index = inp_dict[name]
                    if _index &gt;= 0:
                        index = _index
                    else:
                        index = 0
                    item.setCurrentIndex(index)
                elif isinstance(item, QLineEdit):
                    item.setText(str(inp_dict[name]))
                elif isinstance(item, QCheckBox):
                    item.setChecked(inp_dict[name])

    def run(self):
        self.clear()
        check = self.check_forms()
        if check != True:
            msg = QMessageBox()
            msg.setIcon(QMessageBox.Warning)
            msg.setText(&#34;Input validation error.&#34;)
            msg.setDetailedText(check)
            msg.exec_()
            return

        self.main.emitter_add.connect(self.add_text)
        self.main.emitter_done.connect(self.done)

        if not self.main.running:
            self.main.set_buttons_running()
            self.main.running = True
            self.runner_input = self.main.get_input_params()
            if self.runner_input == None:
                print(&#34;No settings fetched... Terminating.&#34;)
                self.terminate()
                return self.done(True)
            self.main.getter.start()
            self.p = Process(target=calculate_power_3d,
                             args=[self.runner_input])
            self.p.start()
        else:
            msg = QMessageBox()
            msg.setIcon(QMessageBox.Warning)
            msg.setText(&#34;Cannot run while existing operation is running&#34;)
            msg.setInformativeText(
                &#34;The program detected that an existing operation is running.&#34;)
            msg.setWindowTitle(&#34;Runtime error&#34;)
            msg.setDetailedText(&#34;Currently tha value MainWindow.running is %s, \
                it should be False.&#34; % str(self.main.running))
            msg.exec_()

    def add_text(self, string):
        self.textEdit.insertPlainText(string)
        if self.buttonEOF.checkState() == 2:
            self.textEdit.moveCursor(QtGui.QTextCursor.End)

    def done(self, terminated=False):
        self.main.emitter_add.disconnect()
        self.main.emitter_done.disconnect()
        self.main.set_buttons_await()
        self.main.running = False
        self.main.getter.__del__()
        if not terminated:
            self.p.join()
            if len(self.main.return_results) &gt; 0:
                results = self.main.return_results[-1]
                if &#34;v&#34; in results:
                    if len(results[&#34;v&#34;]) &gt; 0:
                        inp_params = self.runner_input
                        r = ResultsWindow(
                            self, self.main.screen_width, self.main.screen_width, results, inp_params, )
                    else:
                        print(&#34;Not enough points to print results...&#34;)
                else:
                    print(&#34;No results to print...&#34;)

    def clear(self):
        self.textEdit.clear()

    def terminate(self):
        if hasattr(self, &#34;p&#34;):
            if self.p.is_alive():
                self.p.terminate()
                self.main.running = False
                self.main.getter.__del__()

                # change to self.done(True), if you dont want to see already calculated points
                self.done(False)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="bem_src.main.Analysis.add_text"><code class="name flex">
<span>def <span class="ident">add_text</span></span>(<span>self, string)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_text(self, string):
    self.textEdit.insertPlainText(string)
    if self.buttonEOF.checkState() == 2:
        self.textEdit.moveCursor(QtGui.QTextCursor.End)</code></pre>
</details>
</dd>
<dt id="bem_src.main.Analysis.check_forms"><code class="name flex">
<span>def <span class="ident">check_forms</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_forms(self):
    out = &#34;&#34;
    for n, f, n_short in self.form_list:
        if isinstance(f, QLineEdit):
            state = self.validator.validate(f.text(), 0)[0]
            if state == QtGui.QValidator.Acceptable:
                pass
            elif state == QtGui.QValidator.Intermediate:
                out += &#34;Form %s appears not to be valid.\n&#34; % n
            else:
                out += &#34;Form %s is not of the valid type.\n&#34; % n
    if out == &#34;&#34;:
        return True
    return out</code></pre>
</details>
</dd>
<dt id="bem_src.main.Analysis.check_state"><code class="name flex">
<span>def <span class="ident">check_state</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_state(self, *args, **kwargs):
    sender = self.sender()
    validator = sender.validator()
    state = validator.validate(sender.text(), 0)[0]
    if state == QtGui.QValidator.Acceptable:
        color = &#34;#edf5e1&#34;  # green
    elif state == QtGui.QValidator.Intermediate:
        color = &#34;#fff79a&#34;  # yellow
    else:
        color = &#34;#f6989d&#34;  # red
    sender.setStyleSheet(&#34;QLineEdit { background-color: %s }&#34; % color)</code></pre>
</details>
</dd>
<dt id="bem_src.main.Analysis.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self):
    self.textEdit.clear()</code></pre>
</details>
</dd>
<dt id="bem_src.main.Analysis.done"><code class="name flex">
<span>def <span class="ident">done</span></span>(<span>self, terminated=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def done(self, terminated=False):
    self.main.emitter_add.disconnect()
    self.main.emitter_done.disconnect()
    self.main.set_buttons_await()
    self.main.running = False
    self.main.getter.__del__()
    if not terminated:
        self.p.join()
        if len(self.main.return_results) &gt; 0:
            results = self.main.return_results[-1]
            if &#34;v&#34; in results:
                if len(results[&#34;v&#34;]) &gt; 0:
                    inp_params = self.runner_input
                    r = ResultsWindow(
                        self, self.main.screen_width, self.main.screen_width, results, inp_params, )
                else:
                    print(&#34;Not enough points to print results...&#34;)
            else:
                print(&#34;No results to print...&#34;)</code></pre>
</details>
</dd>
<dt id="bem_src.main.Analysis.get_settings"><code class="name flex">
<span>def <span class="ident">get_settings</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_settings(self):
    out_settings = {}
    for name, value, name_short in self.form_list:
        name = self.name_to_settings[name]
        if isinstance(value, QCheckBox):
            value = bool(value.checkState())
        if isinstance(value, QLineEdit):
            value = to_float(value.text())
        if isinstance(value, QComboBox):
            value = int(value.currentIndex())
        out_settings[name] = value
    return out_settings</code></pre>
</details>
</dd>
<dt id="bem_src.main.Analysis.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self):
    self.clear()
    check = self.check_forms()
    if check != True:
        msg = QMessageBox()
        msg.setIcon(QMessageBox.Warning)
        msg.setText(&#34;Input validation error.&#34;)
        msg.setDetailedText(check)
        msg.exec_()
        return

    self.main.emitter_add.connect(self.add_text)
    self.main.emitter_done.connect(self.done)

    if not self.main.running:
        self.main.set_buttons_running()
        self.main.running = True
        self.runner_input = self.main.get_input_params()
        if self.runner_input == None:
            print(&#34;No settings fetched... Terminating.&#34;)
            self.terminate()
            return self.done(True)
        self.main.getter.start()
        self.p = Process(target=calculate_power_3d,
                         args=[self.runner_input])
        self.p.start()
    else:
        msg = QMessageBox()
        msg.setIcon(QMessageBox.Warning)
        msg.setText(&#34;Cannot run while existing operation is running&#34;)
        msg.setInformativeText(
            &#34;The program detected that an existing operation is running.&#34;)
        msg.setWindowTitle(&#34;Runtime error&#34;)
        msg.setDetailedText(&#34;Currently tha value MainWindow.running is %s, \
            it should be False.&#34; % str(self.main.running))
        msg.exec_()</code></pre>
</details>
</dd>
<dt id="bem_src.main.Analysis.set_settings"><code class="name flex">
<span>def <span class="ident">set_settings</span></span>(<span>self, inp_dict)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_settings(self, inp_dict):
    for name_long, item, name in self.form_list:
        if name in inp_dict:
            if isinstance(item, QComboBox):
                _index = inp_dict[name]
                if _index &gt;= 0:
                    index = _index
                else:
                    index = 0
                item.setCurrentIndex(index)
            elif isinstance(item, QLineEdit):
                item.setText(str(inp_dict[name]))
            elif isinstance(item, QCheckBox):
                item.setChecked(inp_dict[name])</code></pre>
</details>
</dd>
<dt id="bem_src.main.Analysis.terminate"><code class="name flex">
<span>def <span class="ident">terminate</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def terminate(self):
    if hasattr(self, &#34;p&#34;):
        if self.p.is_alive():
            self.p.terminate()
            self.main.running = False
            self.main.getter.__del__()

            # change to self.done(True), if you dont want to see already calculated points
            self.done(False)</code></pre>
</details>
</dd>
<dt id="bem_src.main.Analysis.update_tsr_and_j"><code class="name flex">
<span>def <span class="ident">update_tsr_and_j</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_tsr_and_j(self):
    try:
        s = self.get_settings()
        R = float(self.main.wind_turbine_properties.R.text())
        tsr_min = 2*np.pi*float(s[&#34;rpm_min&#34;])*R/60/float(s[&#34;v_max&#34;])
        tsr_max = 2*np.pi*float(s[&#34;rpm_max&#34;])*R/60/float(s[&#34;v_min&#34;])
        self.tsr_string.setText(&#34;%.2f - %.2f&#34; % (tsr_min, tsr_max))
        J_min = float(s[&#34;v_min&#34;])/(float(s[&#34;rpm_max&#34;])/60*2*R)
        J_max = float(s[&#34;v_max&#34;])/(float(s[&#34;rpm_min&#34;])/60*2*R)
        self.J_string.setText(&#34;%.2f - %.2f&#34; % (J_min, J_max))
    except:
        print(&#34;couldnt update tsr min/max or J min/max&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="bem_src.main.Curve"><code class="flex name class">
<span>class <span class="ident">Curve</span></span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Curve:
    def __init__(self):
        self.x = None
        self.y = None
        self.Re = None
        self.ncrit = None
        self.alpha = None
        self.cl = None
        self.cd = None
        self.A = None
        self.B = None
        self.Am = None
        self.Bm = None
        self.m_CD90 = None
        self.slope = None

    def create(self, x, y, Re, ncrit, alpha, cl, cd):
        self.x = x
        self.y = y
        self.Re = Re
        self.ncrit = 0.0  # doesnt make any difference for now
        self.alpha = alpha
        self.cl = cl
        self.cd = cd
        self.A = 5
        self.B = 5
        self.Am = 5
        self.Bm = 5
        self.m_CD90 = 2.0
        self.slope = 0.106

    def get_cl_curve(self):
        return self.alpha_cl, self.cl

    def get_extrapolated_curve(self):
        M = Montgomerie(x=self.x, y=self.y, alpha=self.alpha, Cl=self.cl, Cd=self.cd, Re=self.Re, A=self.A, Am=self.Am,
                        B=self.B, Bm=self.Bm, m_CD90=self.m_CD90, slope=self.slope)
        alpha, cl, cd = M.calculate_extrapolation()
        return alpha, cl, cd

    def get_combined_curve(self):
        M = Montgomerie(x=self.x, y=self.y, alpha=self.alpha, Cl=self.cl, Cd=self.cd, Re=self.Re, A=self.A, Am=self.Am,
                        B=self.B, Bm=self.Bm, m_CD90=self.m_CD90, slope=self.slope)
        _alpha, _cl, _cd = M.calculate_extrapolation()
        cl_out, cd_out = [], []
        f_cl = interp1d(self.alpha, self.cl, bounds_error=True)
        f_cd = interp1d(self.alpha, self.cd, bounds_error=True)
        for i in range(len(_alpha)):
            # x.append(self.Re)
            # y.append(m_Alpha[i])
            a = _alpha[i]
            try:
                cl = f_cl(a)
            except ValueError:
                cl = _cl[i]
            # try:
            #     cd = f_cd(a)
            # except ValueError:
            #     cd = _cd[i]
            # tukaj vzamem  samo Montgomerie interpolacijo cd, za lazjo interpolacijo
            cd = _cd[i]
            cl_out.append(cl)
            cd_out.append(cd)
        return _alpha, cl_out, cd_out

    def save_curve(self):
        out = {
            &#34;x&#34;: list(self.x),
            &#34;y&#34;: list(self.y),
            &#34;Re&#34;: self.Re,
            &#34;ncrit&#34;: self.ncrit,
            &#34;alpha&#34;: list(self.alpha),
            &#34;cl&#34;: list(self.cl),
            &#34;cd&#34;: list(self.cd),
            &#34;A&#34;: self.A,
            &#34;B&#34;: self.B,
            &#34;Am&#34;: self.Am,
            &#34;Bm&#34;: self.Bm,
            &#34;m_CD90&#34;: self.m_CD90,
            &#34;slope&#34;: self.slope
        }
        return out

    def load_curve(self, out):
        self.x = out[&#34;x&#34;]
        self.y = out[&#34;y&#34;]
        self.Re = out[&#34;Re&#34;]
        self.ncrit = out[&#34;ncrit&#34;]
        self.alpha = out[&#34;alpha&#34;]
        self.cl = out[&#34;cl&#34;]
        self.cd = out[&#34;cd&#34;]
        self.A = out[&#34;A&#34;]
        self.B = out[&#34;B&#34;]
        self.Am = out[&#34;Am&#34;]
        self.Bm = out[&#34;Bm&#34;]
        self.m_CD90 = out[&#34;m_CD90&#34;]
        self.slope = out[&#34;slope&#34;]</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="bem_src.main.Curve.create"><code class="name flex">
<span>def <span class="ident">create</span></span>(<span>self, x, y, Re, ncrit, alpha, cl, cd)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create(self, x, y, Re, ncrit, alpha, cl, cd):
    self.x = x
    self.y = y
    self.Re = Re
    self.ncrit = 0.0  # doesnt make any difference for now
    self.alpha = alpha
    self.cl = cl
    self.cd = cd
    self.A = 5
    self.B = 5
    self.Am = 5
    self.Bm = 5
    self.m_CD90 = 2.0
    self.slope = 0.106</code></pre>
</details>
</dd>
<dt id="bem_src.main.Curve.get_cl_curve"><code class="name flex">
<span>def <span class="ident">get_cl_curve</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cl_curve(self):
    return self.alpha_cl, self.cl</code></pre>
</details>
</dd>
<dt id="bem_src.main.Curve.get_combined_curve"><code class="name flex">
<span>def <span class="ident">get_combined_curve</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_combined_curve(self):
    M = Montgomerie(x=self.x, y=self.y, alpha=self.alpha, Cl=self.cl, Cd=self.cd, Re=self.Re, A=self.A, Am=self.Am,
                    B=self.B, Bm=self.Bm, m_CD90=self.m_CD90, slope=self.slope)
    _alpha, _cl, _cd = M.calculate_extrapolation()
    cl_out, cd_out = [], []
    f_cl = interp1d(self.alpha, self.cl, bounds_error=True)
    f_cd = interp1d(self.alpha, self.cd, bounds_error=True)
    for i in range(len(_alpha)):
        # x.append(self.Re)
        # y.append(m_Alpha[i])
        a = _alpha[i]
        try:
            cl = f_cl(a)
        except ValueError:
            cl = _cl[i]
        # try:
        #     cd = f_cd(a)
        # except ValueError:
        #     cd = _cd[i]
        # tukaj vzamem  samo Montgomerie interpolacijo cd, za lazjo interpolacijo
        cd = _cd[i]
        cl_out.append(cl)
        cd_out.append(cd)
    return _alpha, cl_out, cd_out</code></pre>
</details>
</dd>
<dt id="bem_src.main.Curve.get_extrapolated_curve"><code class="name flex">
<span>def <span class="ident">get_extrapolated_curve</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_extrapolated_curve(self):
    M = Montgomerie(x=self.x, y=self.y, alpha=self.alpha, Cl=self.cl, Cd=self.cd, Re=self.Re, A=self.A, Am=self.Am,
                    B=self.B, Bm=self.Bm, m_CD90=self.m_CD90, slope=self.slope)
    alpha, cl, cd = M.calculate_extrapolation()
    return alpha, cl, cd</code></pre>
</details>
</dd>
<dt id="bem_src.main.Curve.load_curve"><code class="name flex">
<span>def <span class="ident">load_curve</span></span>(<span>self, out)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_curve(self, out):
    self.x = out[&#34;x&#34;]
    self.y = out[&#34;y&#34;]
    self.Re = out[&#34;Re&#34;]
    self.ncrit = out[&#34;ncrit&#34;]
    self.alpha = out[&#34;alpha&#34;]
    self.cl = out[&#34;cl&#34;]
    self.cd = out[&#34;cd&#34;]
    self.A = out[&#34;A&#34;]
    self.B = out[&#34;B&#34;]
    self.Am = out[&#34;Am&#34;]
    self.Bm = out[&#34;Bm&#34;]
    self.m_CD90 = out[&#34;m_CD90&#34;]
    self.slope = out[&#34;slope&#34;]</code></pre>
</details>
</dd>
<dt id="bem_src.main.Curve.save_curve"><code class="name flex">
<span>def <span class="ident">save_curve</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_curve(self):
    out = {
        &#34;x&#34;: list(self.x),
        &#34;y&#34;: list(self.y),
        &#34;Re&#34;: self.Re,
        &#34;ncrit&#34;: self.ncrit,
        &#34;alpha&#34;: list(self.alpha),
        &#34;cl&#34;: list(self.cl),
        &#34;cd&#34;: list(self.cd),
        &#34;A&#34;: self.A,
        &#34;B&#34;: self.B,
        &#34;Am&#34;: self.Am,
        &#34;Bm&#34;: self.Bm,
        &#34;m_CD90&#34;: self.m_CD90,
        &#34;slope&#34;: self.slope
    }
    return out</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="bem_src.main.CurveControl"><code class="flex name class">
<span>class <span class="ident">CurveControl</span></span>
<span>(</span><span>parent=None, curve=None)</span>
</code></dt>
<dd>
<section class="desc"><p>QWidget(parent: QWidget = None, flags: Union[Qt.WindowFlags, Qt.WindowType] = Qt.WindowFlags())</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CurveControl(QWidget):
    def __init__(self, parent=None, curve=None):
        super(CurveControl, self).__init__(parent)
        # self.setMinimumSize(300,400)
        self.parent = parent

        self.layout = QGridLayout()
        self.setLayout(self.layout)

        self.curve = curve

        self.right = QWidget()
        self.right_layout = QFormLayout()
        self.right.setLayout(self.right_layout)

        self.A = QLineEdit(str(self.curve.A))
        self.B = QLineEdit(str(self.curve.B))
        self.Am = QLineEdit(str(self.curve.Am))
        self.Bm = QLineEdit(str(self.curve.Bm))

        self.A = QSlider(Qt.Horizontal)
        self.A.setMinimum(-10)
        self.A.setMaximum(30)
        self.A.setValue(self.curve.A)
        self.A.setTickPosition(QSlider.TicksBelow)
        self.A.setTickInterval(1)
        self.A.valueChanged.connect(self.update)

        self.B = QSlider(Qt.Horizontal)
        self.B.setMinimum(1)
        self.B.setMaximum(100)
        self.B.setValue(self.curve.B)
        self.B.setTickPosition(QSlider.TicksBelow)
        self.B.setTickInterval(1)
        self.B.valueChanged.connect(self.update)

        self.Am = QSlider(Qt.Horizontal)
        self.Am.setMinimum(1)
        self.Am.setMaximum(80)
        self.Am.setValue(self.curve.Am)
        self.Am.setTickPosition(QSlider.TicksBelow)
        self.Am.setTickInterval(1)
        self.Am.valueChanged.connect(self.update)

        self.Bm = QSlider(Qt.Horizontal)
        self.Bm.setMinimum(1)
        self.Bm.setMaximum(70)
        self.Bm.setValue(self.curve.Bm)
        self.Bm.setTickPosition(QSlider.TicksBelow)
        self.Bm.setTickInterval(1)
        self.Bm.valueChanged.connect(self.update)

        self.m_CD90 = QLineEdit(str(self.curve.m_CD90))
        self.m_CD90.textChanged.connect(self.update)
        self.slope = QLineEdit(str(self.curve.slope))
        self.slope.textChanged.connect(self.update)

        self.right_layout.addRow(&#34;A&#34;, self.A)
        self.right_layout.addRow(&#34;B&#34;, self.B)
        self.right_layout.addRow(&#34;A-&#34;, self.Am)
        self.right_layout.addRow(&#34;B-&#34;, self.Bm)
        self.right_layout.addRow(&#34;CD@90°&#34;, self.m_CD90)
        self.right_layout.addRow(&#34;Slope&#34;, self.slope)

        self.layout.addWidget(self.right, 1, 2)

        self.left = QWidget()
        self.left_layout = QGridLayout()
        self.left.setLayout(self.left_layout)

        self.figure = plt.figure(figsize=(10, 5))
        self.canvas = FigureCanvas(self.figure)
        self.canvas.setMinimumSize(500, 500)
        self.toolbar = NavigationToolbar(self.canvas, self)
        self.ax = self.figure.add_subplot(111)
        self.left_layout.addWidget(self.canvas)
        self.left_layout.addWidget(self.toolbar)

        self.layout.addWidget(self.left, 1, 1)

        self.button_update = QPushButton(&#34;update&#34;)
        self.button_update.clicked.connect(self.draw_extrapolation)
        self.left_layout.addWidget(self.button_update)

        # self.draw_base()

        self.show()

    def clear(self):
        self.ax.cla()

    def draw_base(self):
        self.ax.plot(self.curve.alpha, self.curve.cl)
        self.ax.plot(self.curve.alpha, self.curve.cd, &#34;o-&#34;)
        self.canvas.draw()

    def draw_extrapolation(self):
        self.clear()

        self.draw_base()

        alpha, cl, cd = self.curve.get_extrapolated_curve()
        self.ax.plot(alpha, cl, &#34;g.&#34;)
        self.ax.plot(alpha, cd, &#34;r.&#34;)
        self.canvas.draw()

    def update(self):
        self.curve.A = int(self.A.value())
        self.curve.B = int(self.B.value())
        self.curve.Am = int(self.Am.value())
        self.curve.Bm = int(self.Bm.value())
        try:
            self.curve.m_CD90 = float(self.m_CD90.text())
            self.curve.slope = float(self.slope.text())
            if self.curve.slope == 0:
                self.curve.slope = 1.0
        except:
            print(&#34;Error in slope or m_CD90&#34;)
        self.draw_extrapolation()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="bem_src.main.CurveControl.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self):
    self.ax.cla()</code></pre>
</details>
</dd>
<dt id="bem_src.main.CurveControl.draw_base"><code class="name flex">
<span>def <span class="ident">draw_base</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_base(self):
    self.ax.plot(self.curve.alpha, self.curve.cl)
    self.ax.plot(self.curve.alpha, self.curve.cd, &#34;o-&#34;)
    self.canvas.draw()</code></pre>
</details>
</dd>
<dt id="bem_src.main.CurveControl.draw_extrapolation"><code class="name flex">
<span>def <span class="ident">draw_extrapolation</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_extrapolation(self):
    self.clear()

    self.draw_base()

    alpha, cl, cd = self.curve.get_extrapolated_curve()
    self.ax.plot(alpha, cl, &#34;g.&#34;)
    self.ax.plot(alpha, cd, &#34;r.&#34;)
    self.canvas.draw()</code></pre>
</details>
</dd>
<dt id="bem_src.main.CurveControl.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>update(self)
update(self, QRect)
update(self, QRegion)
update(self, int, int, int, int)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self):
    self.curve.A = int(self.A.value())
    self.curve.B = int(self.B.value())
    self.curve.Am = int(self.Am.value())
    self.curve.Bm = int(self.Bm.value())
    try:
        self.curve.m_CD90 = float(self.m_CD90.text())
        self.curve.slope = float(self.slope.text())
        if self.curve.slope == 0:
            self.curve.slope = 1.0
    except:
        print(&#34;Error in slope or m_CD90&#34;)
    self.draw_extrapolation()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="bem_src.main.CurveViewer"><code class="flex name class">
<span>class <span class="ident">CurveViewer</span></span>
<span>(</span><span>parent=None)</span>
</code></dt>
<dd>
<section class="desc"><p>QWidget(parent: QWidget = None, flags: Union[Qt.WindowFlags, Qt.WindowType] = Qt.WindowFlags())</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CurveViewer(QWidget):
    def __init__(self, parent=None):
        super(CurveViewer, self).__init__(None)
        self.resize(1600, 768)
        self.parent = parent
        self.grid = QGridLayout()
        self.setLayout(self.grid)
        self.button = QPushButton(&#34;Close&#34;)
        self.grid.addWidget(self.button, 1, 1)
        self.button.clicked.connect(self.close)
        self.button_refresh = QPushButton(&#34;Refresh&#34;)
        self.grid.addWidget(self.button_refresh, 1, 2)
        self.button_refresh.clicked.connect(self.generate_views)

        self.bottom = QWidget()
        # self.fbox = QFormLayout()
        self.grid_curves = QGridLayout()
        self.bottom.setLayout(self.grid_curves)

        self.scroll_area = QtWidgets.QScrollArea()
        self.scroll_widget = QtWidgets.QWidget()
        self.scroll_widget_layout = QtWidgets.QVBoxLayout()

        self.scroll_widget.setLayout(self.scroll_widget_layout)
        self.scroll_area.setWidget(self.bottom)
        self.scroll_area.setWidgetResizable(True)
        self.grid.addWidget(self.scroll_area, 2, 1, 2, 2)

        # self.generate_views()

    def generate_views(self):

        # delete stuff already here
        for i in reversed(range(self.grid_curves.count())):
            self.grid_curves.itemAt(i).widget().setParent(None)

        # for i in range(10):
        #    control = CurveControl(self,None)
        #    self.grid_curves.addWidget(control)

        for curve in self.parent.curves.curve_list:
            label = QLabel(&#34;Re:&#34; + str(curve.Re) + &#34;:&#34;)
            control = CurveControl(self, curve)
            control.update()
            self.grid_curves.addWidget(label)
            self.grid_curves.addWidget(control)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="bem_src.main.CurveViewer.generate_views"><code class="name flex">
<span>def <span class="ident">generate_views</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_views(self):

    # delete stuff already here
    for i in reversed(range(self.grid_curves.count())):
        self.grid_curves.itemAt(i).widget().setParent(None)

    # for i in range(10):
    #    control = CurveControl(self,None)
    #    self.grid_curves.addWidget(control)

    for curve in self.parent.curves.curve_list:
        label = QLabel(&#34;Re:&#34; + str(curve.Re) + &#34;:&#34;)
        control = CurveControl(self, curve)
        control.update()
        self.grid_curves.addWidget(label)
        self.grid_curves.addWidget(control)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="bem_src.main.Curves"><code class="flex name class">
<span>class <span class="ident">Curves</span></span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Curves:
    def __init__(self):
        self.curve_list = []

    def add(self, curve):
        self.curve_list.append(curve)

    def save_curves(self):
        out_list = []
        for c in self.curve_list:
            data_curve = c.save_curve()
            out_list.append(data_curve)
        return out_list

    def load_curves(self, out):
        self.curve_list = []
        for data_curve in out:
            c = Curve()
            c.load_curve(data_curve)
            self.curve_list.append(c)

    def gather_curves(self):
        out = []
        for curve in self.curve_list:
            alpha, cl, cd = curve.get_combined_curve()
            # print(alpha,cl,cd)
            for i in range(len(alpha)):
                Re = curve.Re
                ncrit = curve.ncrit
                _alpha = alpha[i]
                _cl = cl[i]
                _cd = cd[i]

                out.append([Re, ncrit, _alpha, _cl, _cd])
        out = np.array(out)
        return out</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="bem_src.main.Curves.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, curve)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, curve):
    self.curve_list.append(curve)</code></pre>
</details>
</dd>
<dt id="bem_src.main.Curves.gather_curves"><code class="name flex">
<span>def <span class="ident">gather_curves</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gather_curves(self):
    out = []
    for curve in self.curve_list:
        alpha, cl, cd = curve.get_combined_curve()
        # print(alpha,cl,cd)
        for i in range(len(alpha)):
            Re = curve.Re
            ncrit = curve.ncrit
            _alpha = alpha[i]
            _cl = cl[i]
            _cd = cd[i]

            out.append([Re, ncrit, _alpha, _cl, _cd])
    out = np.array(out)
    return out</code></pre>
</details>
</dd>
<dt id="bem_src.main.Curves.load_curves"><code class="name flex">
<span>def <span class="ident">load_curves</span></span>(<span>self, out)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_curves(self, out):
    self.curve_list = []
    for data_curve in out:
        c = Curve()
        c.load_curve(data_curve)
        self.curve_list.append(c)</code></pre>
</details>
</dd>
<dt id="bem_src.main.Curves.save_curves"><code class="name flex">
<span>def <span class="ident">save_curves</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_curves(self):
    out_list = []
    for c in self.curve_list:
        data_curve = c.save_curve()
        out_list.append(data_curve)
    return out_list</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="bem_src.main.MainWindow"><code class="flex name class">
<span>class <span class="ident">MainWindow</span></span>
<span>(</span><span>width, height)</span>
</code></dt>
<dd>
<section class="desc"><p>QMainWindow(parent: QWidget = None, flags: Union[Qt.WindowFlags, Qt.WindowType] = Qt.WindowFlags())</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MainWindow(QMainWindow):
    emitter_add = pyqtSignal(str)
    emitter_done = pyqtSignal()

    def __init__(self, width, height):
        super().__init__()

        self.statusBar()
        mainMenu = self.menuBar()
        fileMenu = mainMenu.addMenu(&#39;&amp;File&#39;)
        saveFile = QAction(&#34;&amp;Save File&#34;, self)
        saveFile.setShortcut(&#34;Ctrl+S&#34;)
        saveFile.setStatusTip(&#39;Save File&#39;)
        saveFile.triggered.connect(self.file_save)
        loadFile = QAction(&#34;&amp;Load File&#34;, self)
        loadFile.setShortcut(&#34;Ctrl+L&#34;)
        loadFile.setStatusTip(&#39;Load File&#39;)
        loadFile.triggered.connect(self.file_load)
        getSettings = QAction(&#34;Get settings&#34;, self)
        getSettings.triggered.connect(self.get_all_settings)
        fileMenu.addAction(saveFile)
        fileMenu.addAction(loadFile)
        fileMenu.addAction(getSettings)

        self.screen_width = width
        self.screen_height = height
        self.setGeometry(width * 0.125, height * 0.125,
                         width * 0.75, height * 0.75)
        self.setWindowTitle(TITLE_STR)
        self.tab_widget = TabWidget(self)
        self.setCentralWidget(self.tab_widget)

        self.curve_manager = AirfoilManager(self)
        self.tab_widget.add_tab(self.curve_manager, &#34;Airfoil management&#34;)

        self.wind_turbine_properties = WindTurbineProperties(self)
        self.tab_widget.add_tab(self.wind_turbine_properties, &#34;Turbine info&#34;)

        self.analysis = Analysis(self)
        self.tab_widget.add_tab(self.analysis, &#34;Analysis&#34;)

        self.getter = ThreadGetter(self)

        self.optimization = Optimization(self)
        self.tab_widget.add_tab(self.optimization, &#34;Optimization&#34;)

        self.running = False
        self.manager = Manager()
        self.set_all_settings(SET_INIT)

        create_folder(&#34;foils&#34;)  # Used by XFoil

        self.show()

    def set_title(self):
        s = self.wind_turbine_properties.name.text()
        if s == &#34;&#34;:
            self.setWindowTitle(TITLE_STR)
        else:
            self.setWindowTitle(TITLE_STR + &#34; - &#34; + s)

    def file_save(self):
        name = QFileDialog.getSaveFileName(self, &#39;Save File&#39;)[0]
        if name != &#34;&#34;:
            file = open(name, &#39;w&#39;)
            d = self.get_all_settings()
            d_to_save = fltr(d, (float, int, list, str, bool, numpy.ndarray))
            json_d = json.dumps(d_to_save)
            file.write(json_d)
            file.close()

    def file_load(self):
        file_path = QFileDialog.getOpenFileName(self, &#34;Load File&#34;)[0]
        if file_path != &#34;&#34;:
            with open(file_path, &#34;r&#34;) as fp:
                data = json.load(fp)
            self.set_all_settings(data)
        self.analysis.clear()
        self.optimization.clear()
        self.set_title()

    def get_all_settings(self):

        try:
            valid_foils = list(self.curve_manager.get_settings()[
                &#34;airfoils&#34;].keys()) + [&#34;transition&#34;, &#34;Transition&#34;]
            properties = self.wind_turbine_properties.get_settings()
            settings = self.analysis.get_settings()
            opt_settings = self.optimization.get_settings()
            curve_manager_settings = self.curve_manager.get_settings()

            out = {**properties, **settings, **opt_settings, **curve_manager_settings}
            _r = out[&#34;r&#34;]
            _c = out[&#34;c&#34;]
            _theta = out[&#34;theta&#34;]
            _foils = out[&#34;foils&#34;]
            r, c, theta, foils, dr = interpolate_geom(
                _r, _c, _theta, _foils, out[&#34;num_interp&#34;], out[&#34;linspace_interp&#34;])
            out[&#34;r&#34;], out[&#34;c&#34;], out[&#34;theta&#34;], out[&#34;foils&#34;], out[&#34;dr&#34;] = r, c, theta, foils, dr
            out[&#34;r_in&#34;], out[&#34;c_in&#34;], out[&#34;theta_in&#34;], out[&#34;foils_in&#34;] = _r, _c, _theta, _foils

            return out
        except Exception as e:
            msg = QMessageBox()
            msg.setIcon(QMessageBox.Warning)
            msg.setText(&#34;Error while getting settings&#34;)
            msg.setDetailedText(str(e))
            msg.exec_()
            print(e)
            return None

    # noinspection PyBroadException
    def set_all_settings(self, inp_dict, suppress=True):
        try:
            self.analysis.set_settings(inp_dict)
        except:
            print(&#34;Error setting analysis settings!&#34;)
            if not suppress:
                raise
        try:
            self.optimization.set_settings(inp_dict)
        except:
            print(&#34;Error setting optimization settings!&#34;)
            if not suppress:
                raise
        try:
            self.wind_turbine_properties.set_settings(inp_dict)
        except:
            print(&#34;Error setting wind turbine properties settings!&#34;)
            if not suppress:
                raise
        try:
            self.curve_manager.set_settings(inp_dict)
        except Exception as e:
            print(&#34;Error setting curve manager settings!&#34;)
            if not suppress:
                raise

    def get_input_params(self):
        settings = self.get_all_settings()
        if settings == None:
            return None
        self.return_print = self.manager.list([])
        self.return_results = self.manager.list([])
        self.end_of_file = False
        inp_params = {**settings, &#34;return_print&#34;: self.return_print, &#34;return_results&#34;: self.return_results,
                      &#34;EOF&#34;: self.end_of_file}
        return inp_params

    def set_buttons_running(self):
        self.analysis.buttonRun.setEnabled(False)
        self.optimization.buttonAngles.setEnabled(False)
        self.optimization.buttonBoth.setEnabled(False)
        self.optimization.buttonOptimalPitch.setEnabled(False)
        self.analysis.buttonStop.setEnabled(True)
        self.optimization.buttonStop.setEnabled(True)

    def set_buttons_await(self):
        self.analysis.buttonRun.setEnabled(True)
        self.optimization.buttonAngles.setEnabled(True)
        self.optimization.buttonBoth.setEnabled(True)
        self.optimization.buttonOptimalPitch.setEnabled(True)
        self.analysis.buttonStop.setEnabled(False)
        self.optimization.buttonStop.setEnabled(False)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QMainWindow</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="bem_src.main.MainWindow.emitter_add"><code class="name flex">
<span>def <span class="ident">emitter_add</span></span>(<span>...)</span>
</code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="bem_src.main.MainWindow.emitter_done"><code class="name flex">
<span>def <span class="ident">emitter_done</span></span>(<span>...)</span>
</code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="bem_src.main.MainWindow.file_load"><code class="name flex">
<span>def <span class="ident">file_load</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def file_load(self):
    file_path = QFileDialog.getOpenFileName(self, &#34;Load File&#34;)[0]
    if file_path != &#34;&#34;:
        with open(file_path, &#34;r&#34;) as fp:
            data = json.load(fp)
        self.set_all_settings(data)
    self.analysis.clear()
    self.optimization.clear()
    self.set_title()</code></pre>
</details>
</dd>
<dt id="bem_src.main.MainWindow.file_save"><code class="name flex">
<span>def <span class="ident">file_save</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def file_save(self):
    name = QFileDialog.getSaveFileName(self, &#39;Save File&#39;)[0]
    if name != &#34;&#34;:
        file = open(name, &#39;w&#39;)
        d = self.get_all_settings()
        d_to_save = fltr(d, (float, int, list, str, bool, numpy.ndarray))
        json_d = json.dumps(d_to_save)
        file.write(json_d)
        file.close()</code></pre>
</details>
</dd>
<dt id="bem_src.main.MainWindow.get_all_settings"><code class="name flex">
<span>def <span class="ident">get_all_settings</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_all_settings(self):

    try:
        valid_foils = list(self.curve_manager.get_settings()[
            &#34;airfoils&#34;].keys()) + [&#34;transition&#34;, &#34;Transition&#34;]
        properties = self.wind_turbine_properties.get_settings()
        settings = self.analysis.get_settings()
        opt_settings = self.optimization.get_settings()
        curve_manager_settings = self.curve_manager.get_settings()

        out = {**properties, **settings, **opt_settings, **curve_manager_settings}
        _r = out[&#34;r&#34;]
        _c = out[&#34;c&#34;]
        _theta = out[&#34;theta&#34;]
        _foils = out[&#34;foils&#34;]
        r, c, theta, foils, dr = interpolate_geom(
            _r, _c, _theta, _foils, out[&#34;num_interp&#34;], out[&#34;linspace_interp&#34;])
        out[&#34;r&#34;], out[&#34;c&#34;], out[&#34;theta&#34;], out[&#34;foils&#34;], out[&#34;dr&#34;] = r, c, theta, foils, dr
        out[&#34;r_in&#34;], out[&#34;c_in&#34;], out[&#34;theta_in&#34;], out[&#34;foils_in&#34;] = _r, _c, _theta, _foils

        return out
    except Exception as e:
        msg = QMessageBox()
        msg.setIcon(QMessageBox.Warning)
        msg.setText(&#34;Error while getting settings&#34;)
        msg.setDetailedText(str(e))
        msg.exec_()
        print(e)
        return None</code></pre>
</details>
</dd>
<dt id="bem_src.main.MainWindow.get_input_params"><code class="name flex">
<span>def <span class="ident">get_input_params</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_input_params(self):
    settings = self.get_all_settings()
    if settings == None:
        return None
    self.return_print = self.manager.list([])
    self.return_results = self.manager.list([])
    self.end_of_file = False
    inp_params = {**settings, &#34;return_print&#34;: self.return_print, &#34;return_results&#34;: self.return_results,
                  &#34;EOF&#34;: self.end_of_file}
    return inp_params</code></pre>
</details>
</dd>
<dt id="bem_src.main.MainWindow.set_all_settings"><code class="name flex">
<span>def <span class="ident">set_all_settings</span></span>(<span>self, inp_dict, suppress=True)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_all_settings(self, inp_dict, suppress=True):
    try:
        self.analysis.set_settings(inp_dict)
    except:
        print(&#34;Error setting analysis settings!&#34;)
        if not suppress:
            raise
    try:
        self.optimization.set_settings(inp_dict)
    except:
        print(&#34;Error setting optimization settings!&#34;)
        if not suppress:
            raise
    try:
        self.wind_turbine_properties.set_settings(inp_dict)
    except:
        print(&#34;Error setting wind turbine properties settings!&#34;)
        if not suppress:
            raise
    try:
        self.curve_manager.set_settings(inp_dict)
    except Exception as e:
        print(&#34;Error setting curve manager settings!&#34;)
        if not suppress:
            raise</code></pre>
</details>
</dd>
<dt id="bem_src.main.MainWindow.set_buttons_await"><code class="name flex">
<span>def <span class="ident">set_buttons_await</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_buttons_await(self):
    self.analysis.buttonRun.setEnabled(True)
    self.optimization.buttonAngles.setEnabled(True)
    self.optimization.buttonBoth.setEnabled(True)
    self.optimization.buttonOptimalPitch.setEnabled(True)
    self.analysis.buttonStop.setEnabled(False)
    self.optimization.buttonStop.setEnabled(False)</code></pre>
</details>
</dd>
<dt id="bem_src.main.MainWindow.set_buttons_running"><code class="name flex">
<span>def <span class="ident">set_buttons_running</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_buttons_running(self):
    self.analysis.buttonRun.setEnabled(False)
    self.optimization.buttonAngles.setEnabled(False)
    self.optimization.buttonBoth.setEnabled(False)
    self.optimization.buttonOptimalPitch.setEnabled(False)
    self.analysis.buttonStop.setEnabled(True)
    self.optimization.buttonStop.setEnabled(True)</code></pre>
</details>
</dd>
<dt id="bem_src.main.MainWindow.set_title"><code class="name flex">
<span>def <span class="ident">set_title</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_title(self):
    s = self.wind_turbine_properties.name.text()
    if s == &#34;&#34;:
        self.setWindowTitle(TITLE_STR)
    else:
        self.setWindowTitle(TITLE_STR + &#34; - &#34; + s)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="bem_src.main.MatplotlibWindow"><code class="flex name class">
<span>class <span class="ident">MatplotlibWindow</span></span>
<span>(</span><span>parent=None, curve=None)</span>
</code></dt>
<dd>
<section class="desc"><p>QWidget(parent: QWidget = None, flags: Union[Qt.WindowFlags, Qt.WindowType] = Qt.WindowFlags())</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MatplotlibWindow(QWidget):
    def __init__(self, parent=None, curve=None):
        super(MatplotlibWindow, self).__init__(None)
        self.layout = QGridLayout()
        self.setLayout(self.layout)
        self.figure = plt.figure(figsize=(10, 5))
        self.canvas = FigureCanvas(self.figure)
        self.canvas.setMinimumSize(500, 500)
        self.toolbar = NavigationToolbar(self.canvas, self)
        self.layout.addWidget(self.canvas)
        self.layout.addWidget(self.toolbar)
        # self.ax = self.figure.add_subplot(111)
        self.show()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
</dd>
<dt id="bem_src.main.Optimization"><code class="flex name class">
<span>class <span class="ident">Optimization</span></span>
<span>(</span><span>parent=None)</span>
</code></dt>
<dd>
<section class="desc"><p>QWidget(parent: QWidget = None, flags: Union[Qt.WindowFlags, Qt.WindowType] = Qt.WindowFlags())</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Optimization(QWidget):
    def __init__(self, parent=None):
        super(Optimization, self).__init__(parent)
        self.main = self.parent()

        self.validator = QtGui.QDoubleValidator()
        self.left = QWidget()
        self.textEdit = QTextEdit()
        self.textEdit.setReadOnly(True)

        self.form_list = []

        self.target_speed = QLineEdit()
        self.target_speed.setValidator(self.validator)
        self.target_speed.textChanged.connect(self.check_state)
        self.target_speed.textChanged.emit(self.target_speed.text())
        self._target_speed = QLabel(&#34;Target speed [m/s]&#34;)
        self.form_list.append([self._target_speed, self.target_speed])

        self.target_rpm = QLineEdit()
        self.target_rpm.setValidator(self.validator)
        self.target_rpm.textChanged.connect(self.check_state)
        self.target_rpm.textChanged.emit(self.target_rpm.text())
        self._target_rpm = QLabel(&#34;Target rpm [RPM]&#34;)
        self.form_list.append([self._target_rpm, self.target_rpm])

        self._form = QLabel(&#34;Optimization variable&#34;)
        self.form = QComboBox()
        self.form.addItems(
            [&#34;Thrust (propeller)&#34;, &#34;Torque (Turbine)&#34;, &#34;max dQ min dT&#34;])

        self.buttonAngles = QPushButton(&#34;Run angle optimization&#34;)
        self.buttonAngles.clicked.connect(self.run)

        self.target_rpm_propeller = QLineEdit()
        self.target_rpm_propeller.setValidator(self.validator)
        self.target_rpm_propeller.textChanged.connect(self.check_state)
        self.target_rpm.textChanged.emit(self.target_rpm_propeller.text())
        self._target_rpm_propeller = QLabel(&#39;Target rpm (prop.) [RPM]&#39;)
        self.form_list.append(
            [self._target_rpm_propeller, self.target_rpm_propeller])

        self.buttonBoth = QPushButton(&#39;Run optimization for turbine/propeller&#39;)
        self.buttonBoth.clicked.connect(self.run_both)

        self.buttonOptimalPitch = QPushButton(&#34;Find optimal pitch&#34;)
        self.buttonOptimalPitch.clicked.connect(self.run_optimal_pitch)

        self.buttonStop = QPushButton(&#34;Stop&#34;)
        self.buttonStop.clicked.connect(self.terminate)

        self.buttonClear = QPushButton(&#34;Clear screen&#34;)
        self.buttonClear.clicked.connect(self.clear)

        self.buttonEOF = QCheckBox()
        self.buttonEOF.setChecked(True)
        self.buttonEOFdescription = QLabel(&#34;Scroll to end of screen&#34;)

        self.grid = QGridLayout()
        self.setLayout(self.grid)
        self.grid.addWidget(self.left, 1, 1)
        self.grid.addWidget(self.textEdit, 1, 2)

        self.fbox = QFormLayout()
        self.left.setLayout(self.fbox)
        self.fbox.addRow(self._target_speed, self.target_speed)
        self.fbox.addRow(self._target_rpm, self.target_rpm)
        self.fbox.addRow(self._form, self.form)

        # self.fbox.addRow(QLabel(&#34;--------&#34;))
        self.fbox.addRow(self.buttonAngles)
        self.fbox.addRow(self.buttonOptimalPitch)
        self.fbox.addRow(&#34;&#34;, QLabel())
        self.fbox.addRow(self._target_rpm_propeller, self.target_rpm_propeller)
        self.fbox.addRow(self.buttonBoth)

        self.fbox.addRow(self.buttonClear, self.buttonStop)
        self.fbox.addRow(self.buttonEOFdescription, self.buttonEOF)

    def check_forms_angles(self):
        out = &#34;&#34;
        _needed_vars = [[self._target_speed, self.target_speed], [
            self._target_rpm, self.target_rpm], ]
        for n, f in _needed_vars:
            if isinstance(f, QLineEdit):
                state = self.validator.validate(f.text(), 0)[0]
                if state == QtGui.QValidator.Acceptable:
                    pass
                elif state == QtGui.QValidator.Intermediate:
                    out += &#34;Form %s appears not to be valid.\n&#34; % n.text()
                else:
                    out += &#34;Form %s is not of the valid type.\n&#34; % n.text()
        if out == &#34;&#34;:
            return True
        return out

    def check_state(self, *args, **kwargs):
        sender = self.sender()
        validator = sender.validator()
        state = validator.validate(sender.text(), 0)[0]
        if state == QtGui.QValidator.Acceptable:
            color = &#34;#edf5e1&#34;  # green
        elif state == QtGui.QValidator.Intermediate:
            color = &#34;#fff79a&#34;  # yellow
        else:
            color = &#34;#f6989d&#34;  # red
        sender.setStyleSheet(&#34;QLineEdit { background-color: %s }&#34; % color)

    def run(self):
        self.clear()
        check = self.check_forms_angles()
        check_analysis = self.main.analysis.check_forms()
        if check != True or check_analysis != True:
            if check == True:
                check = &#34;&#34;
            if check_analysis == True:
                check_analysis = &#34;&#34;
            check = check + check_analysis
            msg = QMessageBox()
            msg.setIcon(QMessageBox.Warning)
            msg.setText(&#34;Input validation error&#34;)
            msg.setDetailedText(check)
            msg.exec_()
            return

        self.main.emitter_add.connect(self.add_text)
        self.main.emitter_done.connect(self.done)

        if not self.main.running:
            self.main.set_buttons_running()
            self.main.running = True
            self.runner_input = self.main.get_input_params()
            if self.runner_input[&#34;optimization_variable&#34;] == &#34;dT&#34;:
                self.runner_input[&#34;propeller_mode&#34;] = True
            else:
                self.runner_input[&#34;propeller_mode&#34;] = False
            self.main.getter.start()
            self.p = Process(target=optimize_angles_genetic,
                             args=[self.runner_input])
            self.p.start()
        else:
            msg = QMessageBox()
            msg.setIcon(QMessageBox.Warning)
            msg.setText(&#34;Cannot run while existing operation is running&#34;)
            msg.setInformativeText(
                &#34;The program detected that an existing operation is running.&#34;)
            msg.setWindowTitle(&#34;Runtime error&#34;)
            msg.setDetailedText(&#34;Currently tha value MainWindow.running is %s, \
                it should be False.&#34; % str(self.main.running))

    def run_both(self):
        self.clear()
        check = self.check_forms_angles()
        check_analysis = self.main.analysis.check_forms()
        if check != True or check_analysis != True:
            if check == True:
                check = &#34;&#34;
            if check_analysis == True:
                check_analysis = &#34;&#34;
            check = check + check_analysis
            msg = QMessageBox()
            msg.setIcon(QMessageBox.Warning)
            msg.setText(&#34;Input validation error&#34;)
            msg.setDetailedText(check)
            msg.exec_()
            return

        self.main.emitter_add.connect(self.add_text)
        self.main.emitter_done.connect(self.done)

        if not self.main.running:
            self.main.set_buttons_running()
            self.main.running = True
            self.runner_input = self.main.get_input_params()
            self.main.getter.start()
            self.p = Process(target=maximize_for_both,
                             args=[self.runner_input])
            self.p.start()
        else:
            msg = QMessageBox()
            msg.setIcon(QMessageBox.Warning)
            msg.setText(&#34;Cannot run while existing operation is running&#34;)
            msg.setInformativeText(
                &#34;The program detected that an existing operation is running.&#34;)
            msg.setWindowTitle(&#34;Runtime error&#34;)
            msg.setDetailedText(&#34;Currently tha value MainWindow.running is %s, \
                it should be False.&#34; % str(self.main.running))

    def run_optimal_pitch(self):
        self.clear()
        check = self.check_forms_angles()
        check_analysis = self.main.analysis.check_forms()
        if check != True or check_analysis != True:
            if check == True:
                check = &#34;&#34;
            if check_analysis == True:
                check_analysis = &#34;&#34;
            check = check + check_analysis
            msg = QMessageBox()
            msg.setIcon(QMessageBox.Warning)
            msg.setText(&#34;Input validation error&#34;)
            msg.setDetailedText(check)
            msg.exec_()
            return

        self.main.emitter_add.connect(self.add_text)
        self.main.emitter_done.connect(self.done)

        if not self.main.running:
            self.main.set_buttons_running()
            self.main.running = True
            self.runner_input = self.main.get_input_params()
            self.main.getter.start()
            self.p = Process(target=optimal_pitch, args=[self.runner_input])
            self.p.start()
        else:
            msg = QMessageBox()
            msg.setIcon(QMessageBox.Warning)
            msg.setText(&#34;Cannot run while existing operation is running&#34;)
            msg.setInformativeText(
                &#34;The program detected that an existing operation is running.&#34;)
            msg.setWindowTitle(&#34;Runtime error&#34;)
            msg.setDetailedText(&#34;Currently tha value MainWindow.running is %s, \
                it should be False.&#34; % str(self.main.running))

    def clear(self):
        self.textEdit.clear()

    def add_text(self, string):
        self.textEdit.insertPlainText(string)
        if self.buttonEOF.checkState() == 2:
            self.textEdit.moveCursor(QtGui.QTextCursor.End)

    def run_pitch(self):
        self.run(True)

    def terminate(self):
        if hasattr(self, &#34;p&#34;):
            if self.p.is_alive():
                self.p.terminate()
                self.main.running = False
                self.main.getter.__del__()
                self.done(True)

    def done(self, terminated=False):
        self.main.emitter_add.disconnect()
        self.main.emitter_done.disconnect()
        self.main.set_buttons_await()
        self.main.running = False
        self.main.getter.__del__()
        if not terminated:
            self.p.join()

    def get_settings(self):
        out = {}
        out[&#34;target_rpm&#34;] = self.target_rpm.text()
        out[&#34;target_speed&#34;] = self.target_speed.text()
        out[&#39;target_rpm_propeller&#39;] = self.target_rpm_propeller.text()
        if int(self.form.currentIndex()) == 0:
            out[&#34;optimization_variable&#34;] = &#34;dT&#34;
        elif int(self.form.currentIndex()) == 1:
            out[&#34;optimization_variable&#34;] = &#34;dQ&#34;
        elif int(self.form.currentIndex()) == 2:
            out[&#34;optimization_variable&#34;] = &#34;max dT min dQ&#34;
        for k, v in out.items():
            if v == &#34;&#34;:
                v = None
            elif v == None:
                pass
            else:
                if not k == &#34;optimization_variable&#34;:
                    v = to_float(v)
            out[k] = v
        return out

    def set_settings(self, inp_dict):
        self.target_rpm.setText(str(inp_dict[&#34;target_rpm&#34;]))
        self.target_speed.setText(str(inp_dict[&#34;target_speed&#34;]))
        self.target_rpm_propeller.setText(
            str(inp_dict[&#39;target_rpm_propeller&#39;]))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="bem_src.main.Optimization.add_text"><code class="name flex">
<span>def <span class="ident">add_text</span></span>(<span>self, string)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_text(self, string):
    self.textEdit.insertPlainText(string)
    if self.buttonEOF.checkState() == 2:
        self.textEdit.moveCursor(QtGui.QTextCursor.End)</code></pre>
</details>
</dd>
<dt id="bem_src.main.Optimization.check_forms_angles"><code class="name flex">
<span>def <span class="ident">check_forms_angles</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_forms_angles(self):
    out = &#34;&#34;
    _needed_vars = [[self._target_speed, self.target_speed], [
        self._target_rpm, self.target_rpm], ]
    for n, f in _needed_vars:
        if isinstance(f, QLineEdit):
            state = self.validator.validate(f.text(), 0)[0]
            if state == QtGui.QValidator.Acceptable:
                pass
            elif state == QtGui.QValidator.Intermediate:
                out += &#34;Form %s appears not to be valid.\n&#34; % n.text()
            else:
                out += &#34;Form %s is not of the valid type.\n&#34; % n.text()
    if out == &#34;&#34;:
        return True
    return out</code></pre>
</details>
</dd>
<dt id="bem_src.main.Optimization.check_state"><code class="name flex">
<span>def <span class="ident">check_state</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_state(self, *args, **kwargs):
    sender = self.sender()
    validator = sender.validator()
    state = validator.validate(sender.text(), 0)[0]
    if state == QtGui.QValidator.Acceptable:
        color = &#34;#edf5e1&#34;  # green
    elif state == QtGui.QValidator.Intermediate:
        color = &#34;#fff79a&#34;  # yellow
    else:
        color = &#34;#f6989d&#34;  # red
    sender.setStyleSheet(&#34;QLineEdit { background-color: %s }&#34; % color)</code></pre>
</details>
</dd>
<dt id="bem_src.main.Optimization.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self):
    self.textEdit.clear()</code></pre>
</details>
</dd>
<dt id="bem_src.main.Optimization.done"><code class="name flex">
<span>def <span class="ident">done</span></span>(<span>self, terminated=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def done(self, terminated=False):
    self.main.emitter_add.disconnect()
    self.main.emitter_done.disconnect()
    self.main.set_buttons_await()
    self.main.running = False
    self.main.getter.__del__()
    if not terminated:
        self.p.join()</code></pre>
</details>
</dd>
<dt id="bem_src.main.Optimization.get_settings"><code class="name flex">
<span>def <span class="ident">get_settings</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_settings(self):
    out = {}
    out[&#34;target_rpm&#34;] = self.target_rpm.text()
    out[&#34;target_speed&#34;] = self.target_speed.text()
    out[&#39;target_rpm_propeller&#39;] = self.target_rpm_propeller.text()
    if int(self.form.currentIndex()) == 0:
        out[&#34;optimization_variable&#34;] = &#34;dT&#34;
    elif int(self.form.currentIndex()) == 1:
        out[&#34;optimization_variable&#34;] = &#34;dQ&#34;
    elif int(self.form.currentIndex()) == 2:
        out[&#34;optimization_variable&#34;] = &#34;max dT min dQ&#34;
    for k, v in out.items():
        if v == &#34;&#34;:
            v = None
        elif v == None:
            pass
        else:
            if not k == &#34;optimization_variable&#34;:
                v = to_float(v)
        out[k] = v
    return out</code></pre>
</details>
</dd>
<dt id="bem_src.main.Optimization.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self):
    self.clear()
    check = self.check_forms_angles()
    check_analysis = self.main.analysis.check_forms()
    if check != True or check_analysis != True:
        if check == True:
            check = &#34;&#34;
        if check_analysis == True:
            check_analysis = &#34;&#34;
        check = check + check_analysis
        msg = QMessageBox()
        msg.setIcon(QMessageBox.Warning)
        msg.setText(&#34;Input validation error&#34;)
        msg.setDetailedText(check)
        msg.exec_()
        return

    self.main.emitter_add.connect(self.add_text)
    self.main.emitter_done.connect(self.done)

    if not self.main.running:
        self.main.set_buttons_running()
        self.main.running = True
        self.runner_input = self.main.get_input_params()
        if self.runner_input[&#34;optimization_variable&#34;] == &#34;dT&#34;:
            self.runner_input[&#34;propeller_mode&#34;] = True
        else:
            self.runner_input[&#34;propeller_mode&#34;] = False
        self.main.getter.start()
        self.p = Process(target=optimize_angles_genetic,
                         args=[self.runner_input])
        self.p.start()
    else:
        msg = QMessageBox()
        msg.setIcon(QMessageBox.Warning)
        msg.setText(&#34;Cannot run while existing operation is running&#34;)
        msg.setInformativeText(
            &#34;The program detected that an existing operation is running.&#34;)
        msg.setWindowTitle(&#34;Runtime error&#34;)
        msg.setDetailedText(&#34;Currently tha value MainWindow.running is %s, \
            it should be False.&#34; % str(self.main.running))</code></pre>
</details>
</dd>
<dt id="bem_src.main.Optimization.run_both"><code class="name flex">
<span>def <span class="ident">run_both</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_both(self):
    self.clear()
    check = self.check_forms_angles()
    check_analysis = self.main.analysis.check_forms()
    if check != True or check_analysis != True:
        if check == True:
            check = &#34;&#34;
        if check_analysis == True:
            check_analysis = &#34;&#34;
        check = check + check_analysis
        msg = QMessageBox()
        msg.setIcon(QMessageBox.Warning)
        msg.setText(&#34;Input validation error&#34;)
        msg.setDetailedText(check)
        msg.exec_()
        return

    self.main.emitter_add.connect(self.add_text)
    self.main.emitter_done.connect(self.done)

    if not self.main.running:
        self.main.set_buttons_running()
        self.main.running = True
        self.runner_input = self.main.get_input_params()
        self.main.getter.start()
        self.p = Process(target=maximize_for_both,
                         args=[self.runner_input])
        self.p.start()
    else:
        msg = QMessageBox()
        msg.setIcon(QMessageBox.Warning)
        msg.setText(&#34;Cannot run while existing operation is running&#34;)
        msg.setInformativeText(
            &#34;The program detected that an existing operation is running.&#34;)
        msg.setWindowTitle(&#34;Runtime error&#34;)
        msg.setDetailedText(&#34;Currently tha value MainWindow.running is %s, \
            it should be False.&#34; % str(self.main.running))</code></pre>
</details>
</dd>
<dt id="bem_src.main.Optimization.run_optimal_pitch"><code class="name flex">
<span>def <span class="ident">run_optimal_pitch</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_optimal_pitch(self):
    self.clear()
    check = self.check_forms_angles()
    check_analysis = self.main.analysis.check_forms()
    if check != True or check_analysis != True:
        if check == True:
            check = &#34;&#34;
        if check_analysis == True:
            check_analysis = &#34;&#34;
        check = check + check_analysis
        msg = QMessageBox()
        msg.setIcon(QMessageBox.Warning)
        msg.setText(&#34;Input validation error&#34;)
        msg.setDetailedText(check)
        msg.exec_()
        return

    self.main.emitter_add.connect(self.add_text)
    self.main.emitter_done.connect(self.done)

    if not self.main.running:
        self.main.set_buttons_running()
        self.main.running = True
        self.runner_input = self.main.get_input_params()
        self.main.getter.start()
        self.p = Process(target=optimal_pitch, args=[self.runner_input])
        self.p.start()
    else:
        msg = QMessageBox()
        msg.setIcon(QMessageBox.Warning)
        msg.setText(&#34;Cannot run while existing operation is running&#34;)
        msg.setInformativeText(
            &#34;The program detected that an existing operation is running.&#34;)
        msg.setWindowTitle(&#34;Runtime error&#34;)
        msg.setDetailedText(&#34;Currently tha value MainWindow.running is %s, \
            it should be False.&#34; % str(self.main.running))</code></pre>
</details>
</dd>
<dt id="bem_src.main.Optimization.run_pitch"><code class="name flex">
<span>def <span class="ident">run_pitch</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_pitch(self):
    self.run(True)</code></pre>
</details>
</dd>
<dt id="bem_src.main.Optimization.set_settings"><code class="name flex">
<span>def <span class="ident">set_settings</span></span>(<span>self, inp_dict)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_settings(self, inp_dict):
    self.target_rpm.setText(str(inp_dict[&#34;target_rpm&#34;]))
    self.target_speed.setText(str(inp_dict[&#34;target_speed&#34;]))
    self.target_rpm_propeller.setText(
        str(inp_dict[&#39;target_rpm_propeller&#39;]))</code></pre>
</details>
</dd>
<dt id="bem_src.main.Optimization.terminate"><code class="name flex">
<span>def <span class="ident">terminate</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def terminate(self):
    if hasattr(self, &#34;p&#34;):
        if self.p.is_alive():
            self.p.terminate()
            self.main.running = False
            self.main.getter.__del__()
            self.done(True)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="bem_src.main.PopupText"><code class="flex name class">
<span>class <span class="ident">PopupText</span></span>
<span>(</span><span>parent=None, message='message', default_str='', emitter=None, title='Text popup', text_input=True)</span>
</code></dt>
<dd>
<section class="desc"><p>QWidget(parent: QWidget = None, flags: Union[Qt.WindowFlags, Qt.WindowType] = Qt.WindowFlags())</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PopupText(QWidget):
    def __init__(self, parent=None, message=&#34;message&#34;, default_str=&#34;&#34;, emitter=None, title=&#34;Text popup&#34;, text_input=True):
        QWidget.__init__(self)

        # self.setTitle(title)
        self.emitter = emitter

        self.layout = QGridLayout()
        self.setLayout(self.layout)

        self.message = QLabel(message)

        self.layout.addWidget(self.message, 0, 0)

        if text_input:
            self.inp = QLineEdit()
            self.inp.setText(default_str)
            self.layout.addWidget(self.inp, 1, 0)

        self.button = QPushButton(&#34;OK&#34;)
        self.button.clicked.connect(self.send_signal)
        self.layout.addWidget(self.button, 2, 0)

    def send_signal(self):
        if self.emitter != None:
            self.emitter.emit(self.inp.text())
            self.emitter.disconnect()
        self.close()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="bem_src.main.PopupText.send_signal"><code class="name flex">
<span>def <span class="ident">send_signal</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_signal(self):
    if self.emitter != None:
        self.emitter.emit(self.inp.text())
        self.emitter.disconnect()
    self.close()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="bem_src.main.TabWidget"><code class="flex name class">
<span>class <span class="ident">TabWidget</span></span>
<span>(</span><span>parent=None)</span>
</code></dt>
<dd>
<section class="desc"><p>QTabWidget(parent: QWidget = None)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TabWidget(QtWidgets.QTabWidget):
    def __init__(self, parent=None):
        super(TabWidget, self).__init__(parent)
        self.tabs = []

    def add_tab(self, widget, tab_name):
        for t, n in self.tabs:
            if n == tab_name:
                print(&#34;n&#34;, n, &#34;tab_name&#34;, tab_name)
                msg = QMessageBox()
                msg.setIcon(QMessageBox.Warning)
                msg.setText(&#34;Tab with same name already exists!&#34;)
                msg.exec_()
                return
        self.tabs.append([widget, tab_name])
        self.addTab(widget, tab_name)
        return

    def remove_tab(self, index):
        self.removeTab(index)
        del self.tabs[index]

    def remove_all_tabs(self):
        while len(self.tabs) &gt; 0:
            self.remove_tab(0)

    def remove_current_tab(self):
        self.remove_tab(self.currentIndex())

    def rename_current_tab(self, string):
        self.setTabText(self.currentIndex(), string)
        self.tabs[self.currentIndex()][1] = string

    def current_tab_name(self):
        return self.tabText(self.currentIndex())</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QTabWidget</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="bem_src.main.TabWidget.add_tab"><code class="name flex">
<span>def <span class="ident">add_tab</span></span>(<span>self, widget, tab_name)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_tab(self, widget, tab_name):
    for t, n in self.tabs:
        if n == tab_name:
            print(&#34;n&#34;, n, &#34;tab_name&#34;, tab_name)
            msg = QMessageBox()
            msg.setIcon(QMessageBox.Warning)
            msg.setText(&#34;Tab with same name already exists!&#34;)
            msg.exec_()
            return
    self.tabs.append([widget, tab_name])
    self.addTab(widget, tab_name)
    return</code></pre>
</details>
</dd>
<dt id="bem_src.main.TabWidget.current_tab_name"><code class="name flex">
<span>def <span class="ident">current_tab_name</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def current_tab_name(self):
    return self.tabText(self.currentIndex())</code></pre>
</details>
</dd>
<dt id="bem_src.main.TabWidget.remove_all_tabs"><code class="name flex">
<span>def <span class="ident">remove_all_tabs</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_all_tabs(self):
    while len(self.tabs) &gt; 0:
        self.remove_tab(0)</code></pre>
</details>
</dd>
<dt id="bem_src.main.TabWidget.remove_current_tab"><code class="name flex">
<span>def <span class="ident">remove_current_tab</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_current_tab(self):
    self.remove_tab(self.currentIndex())</code></pre>
</details>
</dd>
<dt id="bem_src.main.TabWidget.remove_tab"><code class="name flex">
<span>def <span class="ident">remove_tab</span></span>(<span>self, index)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_tab(self, index):
    self.removeTab(index)
    del self.tabs[index]</code></pre>
</details>
</dd>
<dt id="bem_src.main.TabWidget.rename_current_tab"><code class="name flex">
<span>def <span class="ident">rename_current_tab</span></span>(<span>self, string)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rename_current_tab(self, string):
    self.setTabText(self.currentIndex(), string)
    self.tabs[self.currentIndex()][1] = string</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="bem_src.main.ThreadGetter"><code class="flex name class">
<span>class <span class="ident">ThreadGetter</span></span>
<span>(</span><span>parent)</span>
</code></dt>
<dd>
<section class="desc"><p>QThread(parent: QObject = None)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ThreadGetter(QThread):
    def __init__(self, parent):
        super(ThreadGetter, self).__init__(parent)

    def __del__(self):
        self.wait()

    def run(self):
        print(&#34;Running Getter.&#34;)
        while True:
            if len(self.parent().return_print) &gt; 0:
                t = self.parent().return_print.pop(0)
                self.parent().emitter_add.emit(str(t))
                if &#34;!!!!EOF!!!!&#34; in t:
                    self.parent().emitter_done.emit()
                    break
            if self.parent().running == False:
                break
        print(&#34;Getter finished.&#34;)
        return</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtCore.QThread</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="bem_src.main.ThreadGetter.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>run(self)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self):
    print(&#34;Running Getter.&#34;)
    while True:
        if len(self.parent().return_print) &gt; 0:
            t = self.parent().return_print.pop(0)
            self.parent().emitter_add.emit(str(t))
            if &#34;!!!!EOF!!!!&#34; in t:
                self.parent().emitter_done.emit()
                break
        if self.parent().running == False:
            break
    print(&#34;Getter finished.&#34;)
    return</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="bem_src.main.WindTurbineProperties"><code class="flex name class">
<span>class <span class="ident">WindTurbineProperties</span></span>
<span>(</span><span>parent=None)</span>
</code></dt>
<dd>
<section class="desc"><p>QWidget(parent: QWidget = None, flags: Union[Qt.WindowFlags, Qt.WindowType] = Qt.WindowFlags())</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class WindTurbineProperties(QWidget):
    def __init__(self, parent=None):
        super(WindTurbineProperties, self).__init__(parent)

        self.main = self.parent()

        grid = QGridLayout()
        self.setLayout(grid)

        left = QWidget()
        fbox = QFormLayout()
        left.setLayout(fbox)

        self.table_properties = Table()
        self.table_properties.createEmpty(4, 30)
        self.table_properties.set_labels(
            [&#34;r [m]&#34;, &#34;c [m]&#34;, &#34;theta [deg]&#34;, &#34;airfoil&#34;])

        grid.addWidget(left, 1, 1)
        grid.addWidget(self.table_properties, 1, 2)

        _name = QLabel(&#34;Turbine Name&#34;)
        self.name = QLineEdit()
        fbox.addRow(_name, self.name)
        self.name.textEdited.connect(self.main.set_title)

        _Rhub = QLabel(&#34;Hub radius [m]&#34;)
        self.Rhub = QLineEdit()
        self.Rhub.setText(&#34;0.1&#34;)
        fbox.addRow(_Rhub, self.Rhub)

        _R = QLabel(&#34;Tip radius [m]&#34;)
        self.R = QLineEdit()
        self.R.setText(&#34;0.776&#34;)
        fbox.addRow(_R, self.R)

        _B = QLabel(&#34;Number of blades&#34;)
        self.B = QLineEdit()
        self.B.setText(&#34;5&#34;)
        fbox.addRow(_B, self.B)

        self.export_button = QPushButton(&#34;Export curve data&#34;)
        self.export_button.clicked.connect(self.export)
        fbox.addRow(&#34;Export:&#34;, self.export_button)

        self.flip_turning_direction = QCheckBox()
        fbox.addRow(&#34;Flip turning direction&#34;, self.flip_turning_direction)

        self.propeller_geom = QCheckBox()
        fbox.addRow(&#34;Propeller&#34;, self.propeller_geom)

    def get_settings(self):
        out_properties = {&#34;Rhub&#34;: to_float(self.Rhub.text()), &#34;R&#34;: to_float(self.R.text()), &#34;B&#34;: int(self.B.text()),
                          &#34;turbine_name&#34;: self.name.text(), }
        geom_array = self.table_properties.get_values()
        r, c, theta, foils = [], [], [], []
        for row in geom_array:
            if row[0] != &#34;&#34; and row[1] != &#34;&#34; and row[2] != &#34;&#34;:
                r.append(to_float(row[0]))
                c.append(to_float(row[1]))
                theta.append(to_float(row[2]))
                foils.append(row[3])
        out_properties[&#34;r&#34;] = numpy.array(r)
        out_properties[&#34;c&#34;] = numpy.array(c)
        out_properties[&#34;theta&#34;] = numpy.array(theta)
        out_properties[&#34;foils&#34;] = foils
        return out_properties

    def set_settings(self, dict_settings):
        if &#34;Rhub&#34; in dict_settings:
            t = str(dict_settings[&#34;Rhub&#34;])
            self.Rhub.setText(t)
        if &#34;R&#34; in dict_settings:
            t = str(dict_settings[&#34;R&#34;])
            self.R.setText(t)
        if &#34;B&#34; in dict_settings:
            t = str(dict_settings[&#34;B&#34;])
            self.B.setText(t)
        if &#34;r_in&#34; in dict_settings and &#34;c_in&#34; in dict_settings and &#34;theta_in&#34; in dict_settings and &#34;foils_in&#34; in dict_settings:
            _array = []
            for r in range(len(dict_settings[&#34;r_in&#34;])):
                _r = dict_settings[&#34;r_in&#34;][r]
                _c = dict_settings[&#34;c_in&#34;][r]
                _theta = dict_settings[&#34;theta_in&#34;][r]
                _f = dict_settings[&#34;foils_in&#34;][r]
                _array.append([_r, _c, _theta, _f])
            self.table_properties.createTable(_array)
        if &#34;turbine_name&#34; in dict_settings:
            t = str(dict_settings[&#34;turbine_name&#34;])
            self.name.setText(t)
        else:
            self.name.setText(&#34;&#34;)

    def export(self):
        print(&#34;Getting settings...&#34;)
        SET_INIT = self.parent().parent().parent().get_all_settings()
        if SET_INIT == None:
            return
        data = create_3d_blade(SET_INIT, self.flip_turning_direction.isChecked(
        ), self.propeller_geom.isChecked())
        w = MatplotlibWindow(self)
        w.ax = w.figure.add_subplot(111, projection=&#34;3d&#34;)
        w.ax.scatter(data[&#34;X&#34;], data[&#34;Y&#34;], data[&#34;Z&#34;])
        X, Y, Z = np.array(data[&#34;X&#34;]), np.array(data[&#34;Y&#34;]), np.array(data[&#34;Z&#34;])
        max_range = np.array(
            [X.max()-X.min(), Y.max()-Y.min(), Z.max()-Z.min()]).max() / 2.0
        mid_x = (X.max()+X.min()) * 0.5
        mid_y = (Y.max()+Y.min()) * 0.5
        mid_z = (Z.max()+Z.min()) * 0.5
        w.ax.set_xlim(mid_x - max_range, mid_x + max_range)
        w.ax.set_ylim(mid_y - max_range, mid_y + max_range)
        w.ax.set_zlim(mid_z - max_range, mid_z + max_range)
        # w.ax.set_aspect(&#34;equal&#34;)

        create_folder(&#34;export&#34;)
        folder_path = os.path.join(&#34;export&#34;, SET_INIT[&#34;turbine_name&#34;])
        create_folder(folder_path)

        filenames = []
        print(&#34;Exporting... (and converting m to mm)&#34;)
        for z, x_data, y_data in data[&#34;data&#34;]:
            print(&#34;Exporting z=&#34;+str(z), &#34;[m]&#34;)
            z = z*1e3  # in mm
            file_name = os.path.join(folder_path, &#34;z_%s.txt&#34; % z)
            filenames.append(os.path.join(os.getcwd(), file_name))
            # print(file_name)
            f = open(os.path.join(folder_path, &#34;z_%s.txt&#34; % z), &#34;w&#34;)
            for x, y in zip(x_data, y_data):
                x, y = x*1e3, y*1e3  # in mm
                f.write(&#34;%s\t%s\t%s\n&#34; % (x, y, z))
            f.close()
        print(&#34;Filenames:&#34;, filenames)
        macro_text = create_macro_text(filenames)

        print(&#34;&#39;===============MACRO START==================&#34;)
        print(macro_text)
        print(&#34;&#39;===============MACRO   END==================&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="bem_src.main.WindTurbineProperties.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self):
    print(&#34;Getting settings...&#34;)
    SET_INIT = self.parent().parent().parent().get_all_settings()
    if SET_INIT == None:
        return
    data = create_3d_blade(SET_INIT, self.flip_turning_direction.isChecked(
    ), self.propeller_geom.isChecked())
    w = MatplotlibWindow(self)
    w.ax = w.figure.add_subplot(111, projection=&#34;3d&#34;)
    w.ax.scatter(data[&#34;X&#34;], data[&#34;Y&#34;], data[&#34;Z&#34;])
    X, Y, Z = np.array(data[&#34;X&#34;]), np.array(data[&#34;Y&#34;]), np.array(data[&#34;Z&#34;])
    max_range = np.array(
        [X.max()-X.min(), Y.max()-Y.min(), Z.max()-Z.min()]).max() / 2.0
    mid_x = (X.max()+X.min()) * 0.5
    mid_y = (Y.max()+Y.min()) * 0.5
    mid_z = (Z.max()+Z.min()) * 0.5
    w.ax.set_xlim(mid_x - max_range, mid_x + max_range)
    w.ax.set_ylim(mid_y - max_range, mid_y + max_range)
    w.ax.set_zlim(mid_z - max_range, mid_z + max_range)
    # w.ax.set_aspect(&#34;equal&#34;)

    create_folder(&#34;export&#34;)
    folder_path = os.path.join(&#34;export&#34;, SET_INIT[&#34;turbine_name&#34;])
    create_folder(folder_path)

    filenames = []
    print(&#34;Exporting... (and converting m to mm)&#34;)
    for z, x_data, y_data in data[&#34;data&#34;]:
        print(&#34;Exporting z=&#34;+str(z), &#34;[m]&#34;)
        z = z*1e3  # in mm
        file_name = os.path.join(folder_path, &#34;z_%s.txt&#34; % z)
        filenames.append(os.path.join(os.getcwd(), file_name))
        # print(file_name)
        f = open(os.path.join(folder_path, &#34;z_%s.txt&#34; % z), &#34;w&#34;)
        for x, y in zip(x_data, y_data):
            x, y = x*1e3, y*1e3  # in mm
            f.write(&#34;%s\t%s\t%s\n&#34; % (x, y, z))
        f.close()
    print(&#34;Filenames:&#34;, filenames)
    macro_text = create_macro_text(filenames)

    print(&#34;&#39;===============MACRO START==================&#34;)
    print(macro_text)
    print(&#34;&#39;===============MACRO   END==================&#34;)</code></pre>
</details>
</dd>
<dt id="bem_src.main.WindTurbineProperties.get_settings"><code class="name flex">
<span>def <span class="ident">get_settings</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_settings(self):
    out_properties = {&#34;Rhub&#34;: to_float(self.Rhub.text()), &#34;R&#34;: to_float(self.R.text()), &#34;B&#34;: int(self.B.text()),
                      &#34;turbine_name&#34;: self.name.text(), }
    geom_array = self.table_properties.get_values()
    r, c, theta, foils = [], [], [], []
    for row in geom_array:
        if row[0] != &#34;&#34; and row[1] != &#34;&#34; and row[2] != &#34;&#34;:
            r.append(to_float(row[0]))
            c.append(to_float(row[1]))
            theta.append(to_float(row[2]))
            foils.append(row[3])
    out_properties[&#34;r&#34;] = numpy.array(r)
    out_properties[&#34;c&#34;] = numpy.array(c)
    out_properties[&#34;theta&#34;] = numpy.array(theta)
    out_properties[&#34;foils&#34;] = foils
    return out_properties</code></pre>
</details>
</dd>
<dt id="bem_src.main.WindTurbineProperties.set_settings"><code class="name flex">
<span>def <span class="ident">set_settings</span></span>(<span>self, dict_settings)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_settings(self, dict_settings):
    if &#34;Rhub&#34; in dict_settings:
        t = str(dict_settings[&#34;Rhub&#34;])
        self.Rhub.setText(t)
    if &#34;R&#34; in dict_settings:
        t = str(dict_settings[&#34;R&#34;])
        self.R.setText(t)
    if &#34;B&#34; in dict_settings:
        t = str(dict_settings[&#34;B&#34;])
        self.B.setText(t)
    if &#34;r_in&#34; in dict_settings and &#34;c_in&#34; in dict_settings and &#34;theta_in&#34; in dict_settings and &#34;foils_in&#34; in dict_settings:
        _array = []
        for r in range(len(dict_settings[&#34;r_in&#34;])):
            _r = dict_settings[&#34;r_in&#34;][r]
            _c = dict_settings[&#34;c_in&#34;][r]
            _theta = dict_settings[&#34;theta_in&#34;][r]
            _f = dict_settings[&#34;foils_in&#34;][r]
            _array.append([_r, _c, _theta, _f])
        self.table_properties.createTable(_array)
    if &#34;turbine_name&#34; in dict_settings:
        t = str(dict_settings[&#34;turbine_name&#34;])
        self.name.setText(t)
    else:
        self.name.setText(&#34;&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="bem_src" href="index.html">bem_src</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="bem_src.main.AirfoilManager" href="#bem_src.main.AirfoilManager">AirfoilManager</a></code></h4>
<ul class="two-column">
<li><code><a title="bem_src.main.AirfoilManager.add_foil" href="#bem_src.main.AirfoilManager.add_foil">add_foil</a></code></li>
<li><code><a title="bem_src.main.AirfoilManager.add_foil_popup" href="#bem_src.main.AirfoilManager.add_foil_popup">add_foil_popup</a></code></li>
<li><code><a title="bem_src.main.AirfoilManager.emitter" href="#bem_src.main.AirfoilManager.emitter">emitter</a></code></li>
<li><code><a title="bem_src.main.AirfoilManager.get_settings" href="#bem_src.main.AirfoilManager.get_settings">get_settings</a></code></li>
<li><code><a title="bem_src.main.AirfoilManager.rename_foil" href="#bem_src.main.AirfoilManager.rename_foil">rename_foil</a></code></li>
<li><code><a title="bem_src.main.AirfoilManager.rename_foil_popup" href="#bem_src.main.AirfoilManager.rename_foil_popup">rename_foil_popup</a></code></li>
<li><code><a title="bem_src.main.AirfoilManager.set_settings" href="#bem_src.main.AirfoilManager.set_settings">set_settings</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="bem_src.main.Airfoils" href="#bem_src.main.Airfoils">Airfoils</a></code></h4>
<ul class="">
<li><code><a title="bem_src.main.Airfoils.calculate_centroid" href="#bem_src.main.Airfoils.calculate_centroid">calculate_centroid</a></code></li>
<li><code><a title="bem_src.main.Airfoils.draw_airfoil" href="#bem_src.main.Airfoils.draw_airfoil">draw_airfoil</a></code></li>
<li><code><a title="bem_src.main.Airfoils.generate_curves_link" href="#bem_src.main.Airfoils.generate_curves_link">generate_curves_link</a></code></li>
<li><code><a title="bem_src.main.Airfoils.generate_curves_xfoil" href="#bem_src.main.Airfoils.generate_curves_xfoil">generate_curves_xfoil</a></code></li>
<li><code><a title="bem_src.main.Airfoils.generate_interp_functions" href="#bem_src.main.Airfoils.generate_interp_functions">generate_interp_functions</a></code></li>
<li><code><a title="bem_src.main.Airfoils.get_max_thickness" href="#bem_src.main.Airfoils.get_max_thickness">get_max_thickness</a></code></li>
<li><code><a title="bem_src.main.Airfoils.get_settings" href="#bem_src.main.Airfoils.get_settings">get_settings</a></code></li>
<li><code><a title="bem_src.main.Airfoils.get_x_y" href="#bem_src.main.Airfoils.get_x_y">get_x_y</a></code></li>
<li><code><a title="bem_src.main.Airfoils.open_viewer" href="#bem_src.main.Airfoils.open_viewer">open_viewer</a></code></li>
<li><code><a title="bem_src.main.Airfoils.populate_curve_list" href="#bem_src.main.Airfoils.populate_curve_list">populate_curve_list</a></code></li>
<li><code><a title="bem_src.main.Airfoils.set_settings" href="#bem_src.main.Airfoils.set_settings">set_settings</a></code></li>
<li><code><a title="bem_src.main.Airfoils.visualize" href="#bem_src.main.Airfoils.visualize">visualize</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="bem_src.main.Analysis" href="#bem_src.main.Analysis">Analysis</a></code></h4>
<ul class="two-column">
<li><code><a title="bem_src.main.Analysis.add_text" href="#bem_src.main.Analysis.add_text">add_text</a></code></li>
<li><code><a title="bem_src.main.Analysis.check_forms" href="#bem_src.main.Analysis.check_forms">check_forms</a></code></li>
<li><code><a title="bem_src.main.Analysis.check_state" href="#bem_src.main.Analysis.check_state">check_state</a></code></li>
<li><code><a title="bem_src.main.Analysis.clear" href="#bem_src.main.Analysis.clear">clear</a></code></li>
<li><code><a title="bem_src.main.Analysis.done" href="#bem_src.main.Analysis.done">done</a></code></li>
<li><code><a title="bem_src.main.Analysis.get_settings" href="#bem_src.main.Analysis.get_settings">get_settings</a></code></li>
<li><code><a title="bem_src.main.Analysis.run" href="#bem_src.main.Analysis.run">run</a></code></li>
<li><code><a title="bem_src.main.Analysis.set_settings" href="#bem_src.main.Analysis.set_settings">set_settings</a></code></li>
<li><code><a title="bem_src.main.Analysis.terminate" href="#bem_src.main.Analysis.terminate">terminate</a></code></li>
<li><code><a title="bem_src.main.Analysis.update_tsr_and_j" href="#bem_src.main.Analysis.update_tsr_and_j">update_tsr_and_j</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="bem_src.main.Curve" href="#bem_src.main.Curve">Curve</a></code></h4>
<ul class="">
<li><code><a title="bem_src.main.Curve.create" href="#bem_src.main.Curve.create">create</a></code></li>
<li><code><a title="bem_src.main.Curve.get_cl_curve" href="#bem_src.main.Curve.get_cl_curve">get_cl_curve</a></code></li>
<li><code><a title="bem_src.main.Curve.get_combined_curve" href="#bem_src.main.Curve.get_combined_curve">get_combined_curve</a></code></li>
<li><code><a title="bem_src.main.Curve.get_extrapolated_curve" href="#bem_src.main.Curve.get_extrapolated_curve">get_extrapolated_curve</a></code></li>
<li><code><a title="bem_src.main.Curve.load_curve" href="#bem_src.main.Curve.load_curve">load_curve</a></code></li>
<li><code><a title="bem_src.main.Curve.save_curve" href="#bem_src.main.Curve.save_curve">save_curve</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="bem_src.main.CurveControl" href="#bem_src.main.CurveControl">CurveControl</a></code></h4>
<ul class="">
<li><code><a title="bem_src.main.CurveControl.clear" href="#bem_src.main.CurveControl.clear">clear</a></code></li>
<li><code><a title="bem_src.main.CurveControl.draw_base" href="#bem_src.main.CurveControl.draw_base">draw_base</a></code></li>
<li><code><a title="bem_src.main.CurveControl.draw_extrapolation" href="#bem_src.main.CurveControl.draw_extrapolation">draw_extrapolation</a></code></li>
<li><code><a title="bem_src.main.CurveControl.update" href="#bem_src.main.CurveControl.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="bem_src.main.CurveViewer" href="#bem_src.main.CurveViewer">CurveViewer</a></code></h4>
<ul class="">
<li><code><a title="bem_src.main.CurveViewer.generate_views" href="#bem_src.main.CurveViewer.generate_views">generate_views</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="bem_src.main.Curves" href="#bem_src.main.Curves">Curves</a></code></h4>
<ul class="">
<li><code><a title="bem_src.main.Curves.add" href="#bem_src.main.Curves.add">add</a></code></li>
<li><code><a title="bem_src.main.Curves.gather_curves" href="#bem_src.main.Curves.gather_curves">gather_curves</a></code></li>
<li><code><a title="bem_src.main.Curves.load_curves" href="#bem_src.main.Curves.load_curves">load_curves</a></code></li>
<li><code><a title="bem_src.main.Curves.save_curves" href="#bem_src.main.Curves.save_curves">save_curves</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="bem_src.main.MainWindow" href="#bem_src.main.MainWindow">MainWindow</a></code></h4>
<ul class="two-column">
<li><code><a title="bem_src.main.MainWindow.emitter_add" href="#bem_src.main.MainWindow.emitter_add">emitter_add</a></code></li>
<li><code><a title="bem_src.main.MainWindow.emitter_done" href="#bem_src.main.MainWindow.emitter_done">emitter_done</a></code></li>
<li><code><a title="bem_src.main.MainWindow.file_load" href="#bem_src.main.MainWindow.file_load">file_load</a></code></li>
<li><code><a title="bem_src.main.MainWindow.file_save" href="#bem_src.main.MainWindow.file_save">file_save</a></code></li>
<li><code><a title="bem_src.main.MainWindow.get_all_settings" href="#bem_src.main.MainWindow.get_all_settings">get_all_settings</a></code></li>
<li><code><a title="bem_src.main.MainWindow.get_input_params" href="#bem_src.main.MainWindow.get_input_params">get_input_params</a></code></li>
<li><code><a title="bem_src.main.MainWindow.set_all_settings" href="#bem_src.main.MainWindow.set_all_settings">set_all_settings</a></code></li>
<li><code><a title="bem_src.main.MainWindow.set_buttons_await" href="#bem_src.main.MainWindow.set_buttons_await">set_buttons_await</a></code></li>
<li><code><a title="bem_src.main.MainWindow.set_buttons_running" href="#bem_src.main.MainWindow.set_buttons_running">set_buttons_running</a></code></li>
<li><code><a title="bem_src.main.MainWindow.set_title" href="#bem_src.main.MainWindow.set_title">set_title</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="bem_src.main.MatplotlibWindow" href="#bem_src.main.MatplotlibWindow">MatplotlibWindow</a></code></h4>
</li>
<li>
<h4><code><a title="bem_src.main.Optimization" href="#bem_src.main.Optimization">Optimization</a></code></h4>
<ul class="two-column">
<li><code><a title="bem_src.main.Optimization.add_text" href="#bem_src.main.Optimization.add_text">add_text</a></code></li>
<li><code><a title="bem_src.main.Optimization.check_forms_angles" href="#bem_src.main.Optimization.check_forms_angles">check_forms_angles</a></code></li>
<li><code><a title="bem_src.main.Optimization.check_state" href="#bem_src.main.Optimization.check_state">check_state</a></code></li>
<li><code><a title="bem_src.main.Optimization.clear" href="#bem_src.main.Optimization.clear">clear</a></code></li>
<li><code><a title="bem_src.main.Optimization.done" href="#bem_src.main.Optimization.done">done</a></code></li>
<li><code><a title="bem_src.main.Optimization.get_settings" href="#bem_src.main.Optimization.get_settings">get_settings</a></code></li>
<li><code><a title="bem_src.main.Optimization.run" href="#bem_src.main.Optimization.run">run</a></code></li>
<li><code><a title="bem_src.main.Optimization.run_both" href="#bem_src.main.Optimization.run_both">run_both</a></code></li>
<li><code><a title="bem_src.main.Optimization.run_optimal_pitch" href="#bem_src.main.Optimization.run_optimal_pitch">run_optimal_pitch</a></code></li>
<li><code><a title="bem_src.main.Optimization.run_pitch" href="#bem_src.main.Optimization.run_pitch">run_pitch</a></code></li>
<li><code><a title="bem_src.main.Optimization.set_settings" href="#bem_src.main.Optimization.set_settings">set_settings</a></code></li>
<li><code><a title="bem_src.main.Optimization.terminate" href="#bem_src.main.Optimization.terminate">terminate</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="bem_src.main.PopupText" href="#bem_src.main.PopupText">PopupText</a></code></h4>
<ul class="">
<li><code><a title="bem_src.main.PopupText.send_signal" href="#bem_src.main.PopupText.send_signal">send_signal</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="bem_src.main.TabWidget" href="#bem_src.main.TabWidget">TabWidget</a></code></h4>
<ul class="two-column">
<li><code><a title="bem_src.main.TabWidget.add_tab" href="#bem_src.main.TabWidget.add_tab">add_tab</a></code></li>
<li><code><a title="bem_src.main.TabWidget.current_tab_name" href="#bem_src.main.TabWidget.current_tab_name">current_tab_name</a></code></li>
<li><code><a title="bem_src.main.TabWidget.remove_all_tabs" href="#bem_src.main.TabWidget.remove_all_tabs">remove_all_tabs</a></code></li>
<li><code><a title="bem_src.main.TabWidget.remove_current_tab" href="#bem_src.main.TabWidget.remove_current_tab">remove_current_tab</a></code></li>
<li><code><a title="bem_src.main.TabWidget.remove_tab" href="#bem_src.main.TabWidget.remove_tab">remove_tab</a></code></li>
<li><code><a title="bem_src.main.TabWidget.rename_current_tab" href="#bem_src.main.TabWidget.rename_current_tab">rename_current_tab</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="bem_src.main.ThreadGetter" href="#bem_src.main.ThreadGetter">ThreadGetter</a></code></h4>
<ul class="">
<li><code><a title="bem_src.main.ThreadGetter.run" href="#bem_src.main.ThreadGetter.run">run</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="bem_src.main.WindTurbineProperties" href="#bem_src.main.WindTurbineProperties">WindTurbineProperties</a></code></h4>
<ul class="">
<li><code><a title="bem_src.main.WindTurbineProperties.export" href="#bem_src.main.WindTurbineProperties.export">export</a></code></li>
<li><code><a title="bem_src.main.WindTurbineProperties.get_settings" href="#bem_src.main.WindTurbineProperties.get_settings">get_settings</a></code></li>
<li><code><a title="bem_src.main.WindTurbineProperties.set_settings" href="#bem_src.main.WindTurbineProperties.set_settings">set_settings</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>